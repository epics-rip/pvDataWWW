<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="keywords"
  content="EPICS, EPICSv4, pvAccess, specification, protocol, network, CAv4" />
  <title>pvAccess Protocol Specification</title>
  <link rel="stylesheet" type="text/css" href="base.css" />
  <link rel="stylesheet" type="text/css" href="epicsv4.css" />
  <style type="text/css">
/*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
p.ed.priv { display: none }
span.ed.priv { display: none }
/*]]>*/</style>
<!-- p and span class "ed priv" is used to specify private editor class. Private -->
<!-- editor class are not displayed when display: none. Turn them to visible with -->
<!-- display: inline. -->
</head>

<body>

<div class="head">
<h1>pvAccess Protocol Specification</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date.  -->

<!-- When making a dated version, change 1. The h2 title. 2. the This Version a tag -->
<!-- text, 3. the This Verison a tag's href URL, 4. The Status of this document -->
  
<h2 class="nocount" id="L50">EPICS v4 Working Group, Third (in progress) Public Working
Draft, 7-April-2014</h2>
<dl>
  <dt>This version:</dt>
    <dd><a
      href="http://epics-pvdata.sourceforge.net/pvAccess_Protocol_Specification_20140407.html">pvAccess_Protocol_Specification_20140407.html</a></dd>
  <dt>Latest version:</dt>
    <dd><a
      href="http://epics-pvdata.sourceforge.net/pvAccess_Protocol_Specification.html">pvAccess_Protocol_Specification.html</a></dd>
  <dt>Previous version:</dt>
    <dd><a
      href="http://epics-pvdata.sourceforge.net/pvAccess_Protocol_Specification_20111129.html">pvAccess_Protocol_Specification_20120905.html</a>
    (2<sup>nd</sup> Public Working Draft)</dd>
  <dt>Editors:</dt>
    <dd>Matej Sekoranja, Cosylab</dd>
    <dd>Marty Kraimer, BNL</dd>
    <dd>Greg White, SLAC, PSI</dd>
    <dd>Andrew Johnson, APS (Invited Expert)</dd>
    <dd>Benjamin Franksen, HZB (Invited Expert)</dd>
    <dd>Michael Abbott, DLS (Invited Expert)</dd>
    <dd>Philip Duval, DESY (Invited Expert)</dd>
</dl>
<hr />
</div>

<h2 class="nocount" id="abstract">Abstract</h2>

<p>This document defines the EPICS Version 4 communication protocol called "pvAccess."
pvAccess is a high-performance network communication protocol for signal
monitoring and scientific data services interconnect. It is designed to support
the structured data types of the EPICS Version 4 "shared memory" data exchange system
called pvData, for optimized interoperability of control system endpoints. It
is a successor of EPICS Channel Access. </p>

<p>The connection setup requirements and individual message constructs of pvAccess
are described. It is intended that sufficient detail is given for a reader to create
an interoperable pvAccess implementation. The protocol and a reference implementation
are being created by the EPICS Version 4
Working Group. </p>

<p>EPICS is a computer platform for building the control systems of large scientific
instruments. For more information about the EPICS, please refer to the home page of the
<a href="http://www.aps.anl.gov/epics/">Experimental Physics and Industrial
Control System. </a></p>

<h2 class="nocount" id="status">Status of this Document</h2>
<!-- Statement about why this version exists -->

<p>This is the 7 April 2014 version of the pvAccess Protocol Specification. This
version consititutes the first publication of the Third Public Working Draft. 
The Third Public Working Draft includes in particular support for unsigned integer, unions, and
material and revisions from the Invited Experts above. The
Public Working Drafts are intended for the EPICS community to review
and comment. Resulting comments will drive subsequent revisions of the
specification and the EPICS Version 4 Working Group's reference implementation.</p>

<p>Missing aspects of this specification are described in the <a href="#missing">last
section</a> at the end of this document.  It is expected that the next draft will
address these remaining items as a Last Call draft, and be followed by publication of
the specification.</p>

<p>The present implementation of pvAccess largely reflects the specification as
written here. Another document will soon be written to track the status of the
reference implementation with respect to the specification, showing what has
yet to be implemented. </p>

<!-- Please always include this statement of terms, unless it's really silly -->
<p>The terms MUST, MUST NOT, SHOULD, SHOULD NOT, REQUIRED, and MAY when
highlighted (through style sheets, and in uppercase in the source) are used in
accordance with <a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a> [<a
href="refs.html#ref-RFC2119">RFC2119</a>]. The term NOT REQUIRED (not defined
in RFC 2119) indicates exemption. </p>

<p>In general the text in this document is intended to be "<a
 href="http://epics-pvdata.sourceforge.net/charter.html#glossary" >normative</a>",
which is to say it constitutes a formal specification of protocol itself. As such that
 text is concise, algorithmic, and describes the protocol
systematically. Such text is in the default font of the document. The functional
consequences of the specification so described, although not normative, may be
important. Such non-normative text is in <i>italics</i>.</p>

<!--NewPage-->
<!-- this is for html2ps -->
</div> <!-- head -->

<h2 class="nocount" id="toc">Table of Contents</h2>

<div class="toc">
<ol>
  <li><a href="#overview">Overview</a></li>
  <li><a href="#dataEncoding">Data Encoding</a>
    <ol>
      <li><a href="#dataEncoding:sizes">Sizes</a></li>
      <li><a href="#dataEncoding:userData">User Data</a>
        <ul>
          <li><a href="#dataEncoding:basicTypes">Basic Types</a></li>
          <li><a href="#dataEncoding:arrays">Arrays</a></li>
          <li><a href="#dataEncoding:strings">Strings</a></li>
          <li><a href="#dataEncoding:structures">Structures</a></li>
          <li><a href="#dataEncoding:unions">Unions</a></li>
          <li><a href="#dataEncoding:variantUnions">Variant Unions</a></li>
          <li><a href="#dataEncoding:example">Encoding example</a></li>
        </ul>
      </li>
      <li><a href="#dataEncoding:metaData">Meta Data</a>
        <ul>
          <li><a href="#dataEncoding:bitSets">BitSets</a>
            <ul>
              <li><a href="#dataEncoding:bitSets:example">Partial Structure
                Serialization</a></li>
            </ul>
          </li>
          <li><a href="#dataEncoding:status">Status</a></li>
          <li><a href="#dataEncoding:introspectionData">Introspection Data</a>
            <ul>
              <li><a href="#dataEncoding:example1">Example #1</a></li>
              <li><a href="#dataEncoding:example2">Example #2</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li><a href="#connectionManagement">Connection Management</a></li>
  <li><a href="#channelLifecycle">Channel Life-cycle</a></li>
  <li><a href="#channelRequestLifecycle">Channel Request Life-cycle</a></li>
  <li><a href="#flowControl">Flow Control</a>
    <ol>
      <li><a href="#flowControlExample">Flow Control Example</a></li>
    </ol>
  </li>
  <li><a href="#channelDiscovery">Channel Discovery</a></li>
  <li><a href="#communicationExample">Communication Example</a></li>
  <li><a href="#protocolMessages">Protocol Messages</a>
    <ol>
      <li><a href="#protocolMessages:messageHeader">Message header</a></li>
    </ol>
  </li>
  <li><a href="#protocolMessages:applicationMessages">Application Messages</a>
    <ol>
      <li><a href="#protocolMessages:applicationMessages:beacon">Beacon
        (0x00)</a></li>
      <li><a
        href="#protocolMessages:applicationMessages:connectionValidation">Connection
        validation (0x01)</a></li>
      <li><a href="#protocolMessages:applicationMessages:echo">Echo
      (0x02)</a></li>
      <li><a href="#protocolMessages:applicationMessages:searchRequest">Search
        request (0x03)</a></li>
      <li><a href="#protocolMessages:applicationMessages:searchResponse">Search
        response (0x04)</a></li>
      <li><a href="#protocolMessages:applicationMessages:createChannel">Create
        channel (0x07)</a></li>
      <li><a
        href="#protocolMessages:applicationMessages:destroyChannel">Destroy
        channel (0x08)</a></li>
      <li><a href="#protocolMessages:applicationMessages:channelGet">Channel
        get (0x0A)</a></li>
      <li><a href="#protocolMessages:applicationMessages:channelPut">Channel
        put (0x0B)</a></li>
      <li><a href="#protocolMessages:applicationMessages:channelPutGet">Channel
        put-get (0x0C)</a></li>
      <li><a
        href="#protocolMessages:applicationMessages:channelMonitor">Channel
        monitor (0x0D)</a></li>
      <li><a href="#protocolMessages:applicationMessages:channelArray">Channel
        array (0x0E)</a></li>
      <li><a
        href="#protocolMessages:applicationMessages:destroyRequest">Destroy
        request (0xF)</a></li>
      <li><a
        href="#protocolMessages:applicationMessages:channelProcess">Channel
        process (0x10)</a></li>
      <li><a href="#protocolMessages:applicationMessages:channelGetField">Get
        channel type introspection data (0x11)</a></li>
      <li><a href="#protocolMessages:applicationMessages:message">Message
        (0x12)</a></li>
      <li><a href="#protocolMessages:applicationMessages:channelRPC">Channel
        RPC (0x14)</a></li>
      <li><a href="#protocolMessages:applicationMessages:cancelRequest">Cancel
        request (0x15)</a></li>
    </ol>
  </li>
  <li><a href="#controlMessages">Control Messages</a>
    <ol>
      <li><a href="#protocolMessages:controlMessages:mark">Mark Total Byte Sent
        (0x00)</a></li>
      <li><a href="#protocolMessages:controlMessages:ackMark">Acknowledge Total
        Bytes Received (0x01)</a></li>
      <li><a href="#protocolMessages:controlMessages:endianess">Set byte order
        (0x02)</a></li>
      <li><a href="#protocolMessages:controlMessages:echoRequest">Echo request
        (0x03)</a></li>
      <li><a href="#protocolMessages:controlMessages:echoResponse">Echo
        response (0x04)</a></li>
    </ol>
  </li>
  <li><a href="#futureProtocolChanges">Future Protocol Changes/Updates</a></li>
  <li><a href="#missing">Missing Aspects</a></li>
</ol>
</div>
<hr />

<div id="contents" class="contents">
<h2 id="overview">Overview</h2>

<p>pvAccess is a high-performance network communication protocol. It is
primarily designed for efficient signal monitoring and the data requirements of
a service oriented architecture. </p>

<p>pvAccess is a successor of <a href="http://www.aps.anl.gov/epics/">EPICS</a>
Channel Access <a class="bib" href="#bib:caref">bib:caref</a>. It is the standard
protocol of <a href="http://epics-pvdata.sourceforge.net/">EPICS Version 4</a> (V4) when
both endpoints of a channel are EPICS V4 agents. pvAccess can also connect EPICS V3
IOC Channel Access data to EPICS V4 user agents, using the EPICS V4 pvIOC module
called <a
 href="ttps://irmis-dev.bnl.gov/jenkins/view/Epics%204/job/pvIOCJava%20-%20Build/javadoc/"
 >CAV3</a>.  </p>

<p>TCP/IP is used for data transmission. UDP/IP is normally used for discovery,
although discovery over TCP/IP is also allowed. The discovery mechanism allows
the use of other implementations (e.g. UDP/IP for data transmission). The
protocol itself supports IPv6, i.e. all addresses are IPv6 encoded. </p>

<p>Port numbers 5075 (tcp connection port, accepted by IANA) and 5076 (udp broadcast port) are used by
default. These default connection ports SHOULD be used if
free, otherwise a dynamically allocated port SHOULD be used as a fallback.  pvAccess
implementations SHOULD allow alternative default connection
ports to be configured.</p>

<p>pvAccess was designed to support pvData <a class="bib"
href="#bib:pvdatarefcpp">bib:pvdatarefcpp</a>,  <a class="bib"
href="#bib:pvdatarefjava">bib:pvdatarefjava</a>. pvData is the control data interface
of EPICS V4 endpoints, such as user agent software and EPICS V4 IOCs. Together with pvAccess, they
support essentially a client-server shared memory system optimized for efficiency
(optimal zero-copy etc) and control (PV locking, alarms etc). The protocol
aims to send the minimum number of bits necessary to inform peers of changes in
endpoint data values subject to performance considerations. That is, it
combines CPU and wire data size considerations to optimize overall control
network throughput. pvAccess supports segmented messages and thus allows the
sending of large amounts of data using optimal buffer sizing. The maximum
message size is not limited with respect to the send or receive buffer sizes.
<i>In practice, this means there is no need for a pvAccess equivalent of
Channel Access' EPICS_CA_MAX_ARRAY_BYTES.</i></p>

<p>The pvAccess protocol definition consists of three major parts:</p>
<ul>
  <li>A set of data encoding rules that determine how the various data types
    are encoded and deserialized</li>
  <li>A set of rules that determine how client and server agree on a particular
    encoding</li>
  <li>A number of message types, that define the interchange between endpoints,
    together with rules which specify what message is to be sent
    under what circumstances.</li>
</ul>

<h2 id="dataEncoding">Data Encoding</h2>

<p>The goals of the pvAccess data encoding are simplicity and efficiency. In keeping
with these goals, the encoding does not align primitive types on word boundaries and
therefore eliminates the wasted space and additional complexity that alignment
requires. The pvAccess data encoding simply produces a stream of contiguous bytes; in
general message data does not contain padding bytes and an implementation MUST NOT
try to align data on word boundaries.</p>

<p>
However, arrays with an element type that is a number (including signed and unsigned
integer types, and floating point types) are an exception.
Such arrays MUST be aligned relative to the start of the message, so that the
first element of the array (and thus all elements) have a byte offset
(relative to the start of the message) that is divisible by the size (in
bytes) of an element of the array. This MUST be done by inserting just enough
bytes before the first element of the array.
For instance, an array of float must be 4 byte aligned, which MUST be ensured
by inserting up to three bytes before the array.
Inserted (padding) bytes value SHOULD be 0x00. 
</p>

<p>For connection-oriented communication (TCP/IP), the server MUST notify the
client what byte order to use. Each message contains an endiannes flag in order
to allow all the intermediates to forward data without requiring it to be
unmarshaled (so that the intermediates can forward requests by simply copying
blocks of binary data) and in order not to require a specific byte order for
connection-less protocols (UDP/IP). </p>

<p>For clarity, this document separates user data (consisting of basic types,
string, arrays, structures) from meta data, which exists only at the protocol
level (Status, BitSet). Meta data can be of user data type, but not the
other way around. </p>

<h3 id="dataEncoding:sizes">Sizes</h3>

<p>Many of the types involved in the data encoding, as well as several protocol
message components, have an associated size (or "count"). Size values MUST
always be a non-negative integer and encoded as follows: </p>
<ol>
  <li>If the number of elements is less than 255, the size MUST be encoded as a
    single byte containing an unsigned 8-bit integer indicating the number of
    elements</li>
  <li>If the number of elements is less than 2^31-1, then the size MUST be
    encoded as an unsigned 8-bit integer with value 255, followed by a positive
    signed 32-bit integer indicating the number of elements</li>
  <li>If the number of elements is greater than or equal to 2^31-1, then the
    size MUST be encoded as an unsigned 8-bit integer with value 255, followed
    by a positive signed 32-bit integer with value 2^31-1, followed by a
    positive signed 64-bit integer indicating the number of elements. This
    implies a maximum size of 2^63-1.</li>
</ol>

<p style="font-style:italic;">Using this encoding to indicate size is significantly
cheaper than always using a 32-bit (or even 64-bit) integer to store the size. This
is especially true when marshalling sequences of short strings; counts of up to 254
require only a single byte instead of four. This comes at the expense of counts
greater than 254, which require five bytes instead of four. However, for sequences or
strings of length greater than 254, the extra byte is insignificant. </p>

<h3 id="dataEncoding:userData">User Data</h3>

<h4 id="dataEncoding:basicTypes">Basic Types</h4>

<p>The basic types MUST be encoded as shown in Table 1. Signed integer types
(byte, short, int, long) MUST be represented as twoâ€™s complement numbers.
Floating point types (float, double) MUST use the IEEE-754 standard formats <a
class="bib" href="#bib:ieee754wiki">bib:ieee754wiki</a>.</p>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Encoding for basic types.</caption>
  <tbody>
    <tr>
      <th>Type</th>
      <th>Encoding</th>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">boolean</td>
      <td>A single byte with value non-zero value for true, zero for false.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">byte</td>
      <td>Signed 8-bit integer.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">ubyte</td>
      <td>Unsigned 8-bit integer.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">short</td>
      <td>Signed 16-bit integer.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">ushort</td>
      <td>Unsigned 16-bit integer.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">int</td>
      <td>Signed 32-bit integer.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">uint</td>
      <td>Unsigned 32-bit integer.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">long</td>
      <td>Signed 64-bit integer.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">ulong</td>
      <td>Unsigned 64-bit integer.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">float</td>
      <td>32-bit float (IEEE-754 single-precision float).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">double</td>
      <td>64-bit float (IEEE-754 double-precision float).</td>
    </tr>
  </tbody>
</table>

<p><i>
Note on boolean encoding: a receiver MUST NOT assume that a boolean value of true is represented
by any special non-zero number, nor that the same sender consistently uses the
same number.
</i></p>

<h4 id="dataEncoding:arrays">Arrays</h4>

<p>Arrays MUST be encoded as a size representing the number of elements in the
array, followed by the elements encoded as specified for their type (as
specified in these sections). </p>

<h4 id="dataEncoding:strings">Strings</h4>

<p>Strings are encoded as arrays of bytes. The actual content (the bytes in the array)
MUST be a valid <a href="http://tools.ietf.org/html/rfc3629">UTF-8</a> encoded string.

<p style="font-style:italic;">Particularly, this means that strings MUST be encoded
as a size, followed by the string contents in a UTF-8 format as bytes. Size gives the
number of bytes that follow it and not the number of UTF-8 characters. UTF-8
multi-byte characters MUST NOT be broken. An empty string MUST be encoded with a size
of zero.</p>

<p style="font-style:italic;">
Implementations that internally use a zero byte or a zero character
to indicate end-of-string SHOULD NOT include a terminating zero byte
in the pvAccess string encoding. 'null' strings are not supported.</p>


<p style="font-style:italic;">On the wire, pvAccess MUST transmit all strings as
Unicode strings in UTF-8.  Non-C++ bindings of the implementations SHOULD use strings
in their language-native Unicode representation and convert automatically to and from
UTF-8 for transmission, so applications can transparently use characters from
non-English alphabets. However, for C++, how strings are represented inside a process
depends on the platform as well as the mapping that is chosen for a particular
string. The default mapping to is std::string. </p>

<h4 id="dataEncoding:structures">Structures</h4>

<p>Structures MUST be encoded by appending the data of all comprising fields in the
order in which the fields have been defined. A structure can contain a
structure and an union (see below) for its field.</p>

<h4 id="dataEncoding:unions">Unions</h4>

<p>Unions MUST be encoded as a selector value (encoded as a size), following
by selected union member data.  The selector chooses one member of an union as specified in the 
union introspection data, so must be a value in the range 0..N-1 where N is the number of union members.
An union can contain a structure and an union for its field.</p>

<h4 id="dataEncoding:variantUnions">Variant Unions</h4>

<p>Variant Unions are open ended union type, also known as <i>any</i> type.
Variant Unions MUST be encoded as a introspection data (<i>Field</i>) description of the encoded value, following
by the encoded value itself.</p>

<h4 id="dataEncoding:example">Encoding example</h4>
<p>Given the following structure:</p>
<pre>structure 
    byte[] value [1,2,3]
    structure timeStamp
        long secondsPastEpoch 0x1122334455667788
        int nanoSeconds 0xAABBCCDD
        int userTag 0xEEEEEEEE
    structure alarm
        int severity 0x11111111
        int status 0x22222222
        string message Allo, Allo!
    union valueUnion
        int  0x33333333
    any variantUnion
        string  String inside variant union.</pre>
        
<p>The above would be serialized as illustrated below (when using big-endian byte order, <i>valueUnion</i> selector with value 1 is selected): </p>
<pre>Hexdump [Serialized structure] size = 75
03 01 02 03  11 22 33 44  55 66 77 88  AA BB CC DD  .... ."3D Ufw. .... 
EE EE EE EE  11 11 11 11  22 22 22 22  0B 41 6C 6C  .... .... """" .All 
6F 2C 20 41  6C 6C 6F 21  01 33 33 33  33 60 1C 53  o, A llo! .333 3`.S 
74 72 69 6E  67 20 69 6E  73 69 64 65  20 76 61 72  trin g in side  var 
69 61 6E 74  20 75 6E 69  6F 6E 2E                  iant  uni on.</pre>

<h3 id="dataEncoding:metaData">Meta Data</h3>

<h4 id="dataEncoding:bitSets">BitSets</h4>

<p>BitSet is a data type that represents a finite sequence of bits.</p>

<p>BitSet is encoded as a byte array. Bits are serialized in groups of eight in
ascending order (LSB to MSB). Serialization is size optimized to
send only the least possible number of bytes that encode all the bits in the
set.</p>

<p>Examples of BitSet serialization: </p>
<pre>Hexdump [{}] size = 1
00                                                 .

Hexdump [{0}] size = 2
01 01                                              ..

Hexdump [{1}] size = 2
01 02                                              ..

Hexdump [{7}] size = 2
01 80                                              ..

Hexdump [{8}] size = 3
02 00 01                                           ...

Hexdump [{15}] size = 3
02 00 80                                           ...

Hexdump [{55}] size = 8
07 00 00 00  00 00 00 80                            .... .... 

Hexdump [{56}] size = 9
08 00 00 00  00 00 00 00  01                       .... .... .

Hexdump [{63}] size = 9
08 00 00 00  00 00 00 00  80                       .... .... .

Hexdump [{64}] size = 10
09 00 00 00  00 00 00 00  00 01                    .... .... ..

Hexdump [{65}] size = 10
09 00 00 00  00 00 00 00  00 02                    .... .... ..

Hexdump [{0, 1, 2, 4}] size = 2
01 17                                              ..

Hexdump [{0, 1, 2, 4, 8}] size = 3
02 17 01                                           ...

Hexdump [{8, 17, 24, 25, 34, 40, 42, 49, 50}] size = 8
07 00 01 02  03 04 05 06                            .... .... 

Hexdump [{8, 17, 24, 25, 34, 40, 42, 49, 50, 56, 57, 58}] size = 9
08 00 01 02  03 04 05 06  07                       .... .... .

Hexdump [{8, 17, 24, 25, 34, 40, 42, 49, 50, 56, 57, 58, 67}] size = 10
09 00 01 02  03 04 05 06  07 08                    .... .... ..

Hexdump [{8, 17, 24, 25, 34, 40, 42, 49, 50, 56, 57, 58, 67, 72, 75}] size = 11
0A 00 01 02  03 04 05 06  07 08 09                 .... .... ...

Hexdump [{8, 17, 24, 25, 34, 40, 42, 49, 50, 56, 57, 58, 67, 72, 75, 81, 83}] size = 12
0B 00 01 02  03 04 05 06  07 08 09 0A               .... .... .... </pre>

<h5 id="dataEncoding:bitSets:example">Partial Structure Serialization</h5>

<p>Each structure can (depending on message definition) have a BitSet instance
defining what subset of that structure's fields have been serialized. This
allows partial serialization of structures. That is, serializing only fields
that have changed rather then the entire structure. Each node of a structure
corresponds to one bit; if a bit is set then its corresponding field has been
serialized, otherwise not. BitSet does not apply to array elements. </p>

<p>This example shows how bits of a BitSet are assigned to the fields of a
structure: </p>
<pre>bit#    field
0    structure 
1        structure timeStamp
2            long secondsPastEpoch 
3            int nanoSeconds 
4            int userTag
5        structure[] value 
            structure org.epics.ioc.test.testStructure
                double value 
                structure location
                    double x
                    double y
            structure org.epics.ioc.test.testStructure
                double value 
                structure location
                    double x
                    double y 
6        string factoryRPC
7        structure arguments
8            int size
</pre>

<p>The structure above requires a BitSet that contains 9 bits.<br />
If the bit corresponding to a structure node is set, then all the fields of
that node MUST be serialized. </p>

<h4 id="dataEncoding:status">Status</h4>

<p>pvAccess defines a structure to inform endpoints about completion status. It
is nominally defined as: </p>
<pre>struct Status {
    byte type;      // enum { OK = 0, WARNING = 1, ERROR = 2, FATAL = 3 }
    string message;
    string callTree;   // optional (provides more context data about the error), can be empty
};</pre>

<p>In practice, since the majority of Status instances would be OK with no
message and no callTree, a special definition of Status SHOULD be used in the
common case that all three of these conditions are met; if Status is OK
and no message and no callTree would be sent, then the special type value of
<code>-1</code> MAY be used, and in this case the string fields are omitted: </p>
<pre>struct StatusOK {
    byte type = -1;
};</pre>

<p>Examples of Status serialization: </p>
<pre>Hexdump [Status OK] size = 1
FF                                                 .

Hexdump [WARNING, "Low memory", ""] size = 13
01 0A 4C 6F  77 20 6D 65  6D 6F 72 79  00          ..Lo w me mory .

Hexdump [ERROR, "Failed to get, due to unexpected exception", (call tree)] size = 264
02 2A 46 61  69 6C 65 64  20 74 6F 20  67 65 74 2C  .*Fa iled  to  get, 
20 64 75 65  20 74 6F 20  75 6E 65 78  70 65 63 74   due  to  unex pect 
65 64 20 65  78 63 65 70  74 69 6F 6E  DB 6A 61 76  ed e xcep tion .jav 
61 2E 6C 61  6E 67 2E 52  75 6E 74 69  6D 65 45 78  a.la ng.R unti meEx 
63 65 70 74  69 6F 6E 0A  09 61 74 20  6F 72 67 2E  cept ion. .at  org. 
65 70 69 63  73 2E 63 61  2E 63 6C 69  65 6E 74 2E  epic s.ca .cli ent. 
65 78 61 6D  70 6C 65 2E  53 65 72 69  61 6C 69 7A  exam ple. Seri aliz 
61 74 69 6F  6E 45 78 61  6D 70 6C 65  73 2E 73 74  atio nExa mple s.st 
61 74 75 73  45 78 61 6D  70 6C 65 73  28 53 65 72  atus Exam ples (Ser 
69 61 6C 69  7A 61 74 69  6F 6E 45 78  61 6D 70 6C  iali zati onEx ampl 
65 73 2E 6A  61 76 61 3A  31 31 38 29  0A 09 61 74  es.j ava: 118) ..at 
20 6F 72 67  2E 65 70 69  63 73 2E 63  61 2E 63 6C   org .epi cs.c a.cl 
69 65 6E 74  2E 65 78 61  6D 70 6C 65  2E 53 65 72  ient .exa mple .Ser 
69 61 6C 69  7A 61 74 69  6F 6E 45 78  61 6D 70 6C  iali zati onEx ampl 
65 73 2E 6D  61 69 6E 28  53 65 72 69  61 6C 69 7A  es.m ain( Seri aliz 
61 74 69 6F  6E 45 78 61  6D 70 6C 65  73 2E 6A 61  atio nExa mple s.ja 
76 61 3A 31  32 36 29 0A                            va:1 26). </pre>

<h4 id="dataEncoding:introspectionData">Introspection Data</h4>

<p>Introspection data describes the type of a user data item. It is not itself
user data, but rather meta data. Introspection data appears in one of four
forms: no introspection data (NULL_TYPE_CODE), or a full type description
(FULL_TYPE_CODE), or a type identifier (ONLY_ID_TYPE_CODE), or both
(FULL_WITH_ID_TYPE_CODE), according to table "Encoding of Introspection Data".
</p>

<p>The sender MUST send introspection data, but is free to chose one of the
above methods. Sending FULL_WITH_ID_TYPE_CODE defines the type identifier for
subsequent sends using ONLY_ID_TYPE_CODE. Therefore, before sending
ONLY_ID_TYPE_CODE, the sender MUST have previously sent at least one
FULL_WITH_ID_TYPE_CODE with the same type identifier to the same receiver. </p>

<p>Since user data types can be arbitrarily complex, introspection data SHOULD
be sent only once per type and receiver combination. The mapping of dynamically assigned
type identifier (ID) to introspection data MUST be cached on the receiver side,
and SHOULD be cached and re-used on the sender side. ID MUST be encoded as
short and MUST be valid only within one connection. Moreover, IDs MUST be
assigned only by the sender. The receiver MUST keep track of the IDs and
use them to identify deserializations. Since communication is full-duplex this
implies there MUST be two introspection registries per connection. The sender
MAY override a previously assigned ID by simply assiging the ID to a new
introspection data instance. Introspection registry size MUST be negotiated
when each connection is established. </p>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Encoding of Introspection Data (called
  Field for future reference).</caption>
  <tbody>
    <tr>
      <th>Field Encoding</th>
      <th>Name</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>0xFF</td>
      <td style="font-weight:bold">NULL_TYPE_CODE</td>
      <td>No introspection data (also implies no data).</td>
    </tr>
    <tr>
      <td>0xFE + ID</td>
      <td style="font-weight:bold">ONLY_ID_TYPE_CODE</td>
      <td>Serialization contains only an ID (that was assigned by one of the
        previous FULL_WITH_ID_TYPE_CODE or FULL_TAGGED_ID_TYPE_CODE descriptions).</td>
    </tr>
    <tr>
      <td>0xFD + ID + FieldDesc</td>
      <td style="font-weight:bold">FULL_WITH_ID_TYPE_CODE</td>
      <td>Serialization contains an ID (that can be used later, if cached) and
        full interface description. Any existing definition with the same ID is overriden.</td>
    </tr>
    <tr>
      <td>0xFC + ID + tag + FieldDesc</td>
      <td style="font-weight:bold">FULL_TAGGED_ID_TYPE_CODE</td>
      <td>Serialization contains an ID (that can be used later, if cached), tag (of integer type) and
        full interface description. Any existing definition with the same ID is overriden.
        A tag must guarantee that the same (ID, FieldDesc) pair has the same tag and any previous definition
        with the same ID and different FieldDesc has a different tag. In non-reliable transport systems this
        identifies whether the definition with given ID overrides already existing one and allow receivers to skip deserialization of FieldDesc, if tags match.<br/>
      </td>
    </tr>
    <tr>
      <td>0xFB - 0xE0</td>
      <td>RESERVED</td>
      <td>Reserved for future usage, MUST NOT be used.</td>
    </tr>
    <tr>
      <td>FieldDesc<br />
        (0xDF - 0x00)</td>
      <td style="font-weight:bold">FULL_TYPE_CODE</td>
      <td>Serialization contains only full interface description.</td>
    </tr>
  </tbody>
</table>

<p>Each instance of a Field introspection description (FieldDesc) MUST be encoded as a
byte that consists of 2 nibbles (4-bits). The upper nibble (Most Significant
Bits, MSBs) is used for the type selector and flags. The lower nibble (bits 7-5) is type
dependent and used for size encoding. </p>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Type Encoding.</caption>
  <tbody>
    <tr>
      <th>bit</th>
      <th>Value</th>
      <th>Description</th>
    </tr>
    <tr>
      <td rowspan="8" style="text-align:right;font-family:monospace">7-5</td>
      <td style="text-align:right;font-family:monospace">111</td>
      <td>reserved (MUST never be used)</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">110</td>
      <td rowspan="2">reserved (MUST not be used)</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">101</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">100</td>
      <td>complex</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">011</td>
      <td style="font-weight:bold">string</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">010</td>
      <td>floating-point</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">001</td>
      <td>integer</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">000</td>
      <td style="font-weight:bold">boolean</td>
    </tr>
    <tr>
      <td rowspan="2" style="text-align:right;font-family:monospace">4</td>
      <td style="text-align:right;font-family:monospace">1</td>
      <td>array flag</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">0</td>
      <td>scalar flag</td>
    </tr>
    <tr>
      <td rowspan="1" style="text-align:right;font-family:monospace">3-0</td>
      <td style="text-align:right;font-family:monospace"></td>
      <td>type (bits 7-5) depended</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Integer Type Size Encoding (type =
  '0b001').</caption>
  <tbody>
    <tr>
      <th>bit</th>
      <th>Value</th>
      <th>Type Name</th>
    </tr>
    <tr>
      <td rowspan="2" style="text-align:right;font-family:monospace">3</td>
      <td style="text-align:right;font-family:monospace">1</td>
      <td>unsigned flag</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">0</td>
      <td>signed flag</td>
    </tr>
    <tr>
      <td rowspan="8" style="text-align:right;font-family:monospace">2-0</td>
      <td style="text-align:right;font-family:monospace">111</td>
      <td rowspan="4">reserved</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">110</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">101</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">100</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">011</td>
      <td style="font-weight:bold">long</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">010</td>
      <td style="font-weight:bold">int</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">001</td>
      <td style="font-weight:bold">short</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">000</td>
      <td style="font-weight:bold">byte</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Floating-Point Size Encoding (type =
  '0b010').</caption>
  <tbody>
    <tr>
      <th>bit</th>
      <th>Value</th>
      <th>Type Name</th>
      <th>IEEE 754-2008 Name</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">3</td>
      <td style="text-align:right;font-family:monospace"></td>
      <td colspan="2">reserved</td>
    </tr>
    <tr>
      <td rowspan="8" style="text-align:right;font-family:monospace">2-0</td>
      <td style="text-align:right;font-family:monospace">111</td>
      <td colspan="2" rowspan="3">reserved</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">110</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">101</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">100</td>
      <td>reserved</td>
      <td>binary128 (Quadruple)</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">011</td>
      <td style="font-weight:bold">double</td>
      <td>binary64 (Double)</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">010</td>
      <td style="font-weight:bold">float</td>
      <td>binary32 (Single)</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">001</td>
      <td>reserved</td>
      <td>binary16 (Half)</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">000</td>
      <td colspan="2">reserved</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Complex Type Encoding (type =
  '0b100').</caption>
  <tbody>
    <tr>
      <th>bit</th>
      <th>Value</th>
      <th>Type Name</th>
    </tr>
    <tr>
      <td rowspan="16" style="text-align:right;font-family:monospace">3-0</td>
      <td style="text-align:right;font-family:monospace">1111</td>
      <td rowspan="13">reserved</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">1110</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">1101</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">1100</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">1011</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">1010</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">1001</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">1000</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">0111</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">0110</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">0101</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">0100</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">0011</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">0010</td>
      <td style="font-weight:bold">variant union</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">0001</td>
      <td style="font-weight:bold">union</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">0000</td>
      <td style="font-weight:bold">structure</td>
    </tr>
  </tbody>
</table>

<p>For all other types, bits 3-0 MUST be '0b0000'. </p>

<p>Structure and union (and their arrays) REQUIRE more description. A
structure REQUIRES its identification string and a named array of Fields - size followed by one or more (field name, FieldDesc) pairs.
Arrays of structures/unions REQUIRE an introspection data of a
structure/union defining an array element type.</p>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">FieldDesc Encoding.</caption>
  <tbody>
    <tr>
      <th>FieldDesc Encoding</th>
      <!--th>Type</th-->
      <th>Description</th>
    </tr>
    <tr>
      <td><a style="font-family:monospace">0bxxx0xxxx</a></td>
      <!--td style="font-weight:bold">scalar</td-->
      <td>Scalar.</td>
    </tr>
    <tr>
      <td><a style="font-family:monospace">0bxxx1xxxx</a></td>
      <!--td style="font-weight:bold">scalarArray</td-->
      <td>Array of scalars.</td>
    </tr>
    <tr>
      <td><a style="font-family:monospace">0b10000000</a> + identification string + (field name, FieldDesc)[]</td>
      <!--td style="font-weight:bold">structure</td-->
      <td>Structure.</td>
    </tr>
    <tr>
      <td><a style="font-family:monospace">0b10010000</a> + structure FieldDesc</td>
      <!--td style="font-weight:bold">structureArray</td-->
      <td>Array of structures.</td>
    </tr>
    <tr>
      <td><a style="font-family:monospace">0b10000001</a> + identification string + (field name, FieldDesc)[]</td>
      <!--td style="font-weight:bold">union</td-->
      <td>Union.</td>
    </tr>
    <tr>
      <td><a style="font-family:monospace">0b10010001</a> + union FieldDesc</td>
      <!--td style="font-weight:bold">unionArray</td-->
      <td>Array of unions.</td>
    </tr>
    <tr>
      <td><a style="font-family:monospace">0b10000010</a></td>
      <!--td style="font-weight:bold">union</td-->
      <td>Variant union.</td>
    </tr>
    <tr>
      <td><a style="font-family:monospace">0b10010010</a></td>
      <!--td style="font-weight:bold">unionArray</td-->
      <td>Array of variant unions.</td>
    </tr>
  </tbody>
</table>

<h5 id="dataEncoding:example1">Example #1</h5>

<p>Given the following structure, as may be expressed by a pvData Structure:
</p>
<pre>
timeStamp_t
    long secondsPastEpoch
    int nanoSeconds
    int userTag</pre>

<p>The introspection description of the above structure is be encoded by
pvAccess as the following: </p>
<pre>Hexdump [Serialized structure IF] size = 57
FD 00 01 80  0B 74 69 6D  65 53 74 61  6D 70 5F 74  .... .tim eSta mp_t 
03 10 73 65  63 6F 6E 64  73 50 61 73  74 45 70 6F  ..se cond sPas tEpo 
63 68 23 0B  6E 61 6E 6F  53 65 63 6F  6E 64 73 22  ch#. nano Seco nds" 
07 75 73 65  72 54 61 67  22                        .use rTag "</pre>

<h5 id="dataEncoding:example2">Example #2</h5>

<p>Given the following structure, as may be expressed by a pvData Structure:
</p>
<pre>
exampleStructure
    byte[] value
    time_t timeStamp
        long secondsPastEpoch
        int nanoSeconds
        int userTag
    alarm_t alarm
        int severity
        int status
        string message
    union valueUnion
        string stringValue
        int intValue
        double doubleValue
    any variantUnion</pre>

<p>The introspection description of the above structure would be encoded by
pvAccess as the following: </p>
<pre>Hexdump [Serialized structure IF] size = 201
FD 00 01 80  10 65 78 61  6D 70 6C 65  53 74 72 75  .... .exa mple Stru 
63 74 75 72  65 05 05 76  61 6C 75 65  30 09 74 69  ctur e..v alue 0.ti 
6D 65 53 74  61 6D 70 FD  00 01 80 06  74 69 6D 65  meSt amp. .... time 
5F 74 03 10  73 65 63 6F  6E 64 73 50  61 73 74 45  _t.. seco ndsP astE 
70 6F 63 68  23 0B 6E 61  6E 6F 53 65  63 6F 6E 64  poch #.na noSe cond 
73 22 07 75  73 65 72 54  61 67 22 05  61 6C 61 72  s".u serT ag". alar 
6D FD 00 02  80 07 61 6C  61 72 6D 5F  74 03 08 73  m... ..al arm_ t..s 
65 76 65 72  69 74 79 22  06 73 74 61  74 75 73 22  ever ity" .sta tus" 
07 6D 65 73  73 61 67 65  60 0A 76 61  6C 75 65 55  .mes sage `.va lueU 
6E 69 6F 6E  81 00 03 0B  73 74 72 69  6E 67 56 61  nion .... stri ngVa 
6C 75 65 60  08 69 6E 74  56 61 6C 75  65 22 0B 64  lue` .int Valu e".d 
6F 75 62 6C  65 56 61 6C  75 65 43 0C  76 61 72 69  oubl eVal ueC. vari 
61 6E 74 55  6E 69 6F 6E  82                        antU nion .</pre>

<h2 id="connectionManagement">Connection Management</h2>

<p>pvAccess uses the concept of a "channel" to denote a connection to a single
named resource that resides on some server. Channels are subordinate to the TCP
connection between a client and server: a channel can only be created if a TCP
connection has already been established; likewise, if the TCP connection is
terminated, then all subordinate channels are implicitly destroyed. </p>

<p>Each TCP connection has associated Quality of Service (QoS) parameters. Regardless
of how many channels are handled by either client or server, each client and server
pair MUST be connected with exactly one TCP connection for each QoS parameter value.
</p>

<p>When establishing a TCP connection, a simple handshake MUST be performed.
The client opens a TCP connection to the server and waits until the Connection
Validation message is received. The server MUST initially send a Set byte order
control message to notify the client about the byte order to be used for this TCP
connection. After that the server MUST send the Connection Validation message.
If the client correctly decodes messages it MUST respond with a Connection Validation
response message. Now the connection is verified and the client may start
sending requests. The client SHOULD keep the connection established until the
last active channel gets destroyed. However, to optimize resource reallocation
it MAY delay connection destruction. </p>

<p>Both parties MUST constantly monitor whether the connection is valid and not
simply rely on TCP mechanisms. pvAccess achieves this by sending some small amount of
data with a minimum period.  If there is no send operation otherwise called within a
predetermined period of time (SHOULD be 15 seconds), an echo message MUST be sent. In case of
connection failure, TCP will report connection loss on send. If there is no response
in in predetermined period of time, the connection SHOULD be marked as
unresponsive. Echo message MUST be periodically sent until response is received or
the connection is reported to be lost. If echo response is received and transport is
marked as unresponsive, transport SHOUD be reported to be responsive. </p>

<div class="image" style="text-align:center">
<img src="image/pvAccessSpec_ConnectionStates.png"
alt="Connection State Diagram" width="66%" /> 

<div style="font-weight:bold">
Connection State Diagram.</div>
</div>

<p>When connection is terminated all related resources MUST be freed. On the server
side all channels including their requests MUST be destroyed (this includes all
<i>serverChannelID</i>s). On the client side all channels and their requests MUST
be put to disconnected state and searching for channels initiated.
<i>clientChannelID</i>s and <i>requestID</i>s SHOULD be retained until channel
or request are destroyed on client side. Once IDs are freed they MAY be
recycled - used for other channels/requests in the future.</p>

<p> When disconnected client channels are found on the network and connection is
re-established, channels are put back to connected state and all their requests
re-initialized; in addition, monitors are re-started. </p>

<h2 id="channelLifecycle">Channel Life-cycle</h2>

<div class="image" style="text-align:center">
<img src="image/pvAccessSpec_ChannelStates.png" alt="Channel State Diagram"
width="66%" /> 

<div style="font-weight:bold">
Channel State Diagram.</div>
</div>

<p>When a channel is instantiated by a client application, its state MUST be
set to NEVER_CONNECTED state. This indicates that the channel is currently
being connected for the first time. Connection proccess within the client MUST
repetedly attempt to find a server hosting the channel by
broadcasting or multicasting channel search requests. When a server response is
received, the client MUST connect to the server responding to the search
request using the protocol and address data from the search request response. If
a connection has been already established by the client, it MUST be reused. A client API
MAY also allow a user-specified server address; in this case, the searching process
would be bypassed and the specified server address data used directly. </p>

<p>When connection is established and verified, the channel create request
message MUST be sent by the server. When the client receives a channel create
response message with success status, it MUST set the channel to CONNECTED
state. </p>

<p>A channel MUST be in CONNECTED state to be able to accept channel related
requests. </p>

<p>When the connection is lost, the channel state MUST be set to DISCONNECTED.
In this state, clients MUST start the connection process as descibed above. On
reconnect, the channel's state MUST be set back to CONNECTED. </p>

<p>A channel MAY be destroyed any time (in any state) and then its state MUST
be set to DESTROYED. Once the channel is destroyed, it MUST NOT be used
anymore. </p>

<h2 id="channelRequestLifecycle">Channel Request Life-cycle</h2>

<div class="image" style="text-align:center">
<img src="image/pvAccessSpec_RequestStates.png"
alt="Channel Request State Diagram" width="66%" /> 

<div style="font-weight:bold">
Channel Request State Diagram.</div>
</div>

<p>Channel requests (get, put, get-put, RPC, process) have a state. When
instantiated, they MUST be set to INIT state. A specific per request
initialization message MUST be sent to the server. The request MUST NOT be used
until successful initialization response is received from the server and put to
READY state. If initialization fails, the client MUST be notified about failure and
the request put to DESTROYED state. </p>

<p>Actual actions, e.g. get, MAY only be invoked when a request is in READY
state. When one action is in progress, the request is put to
REQUEST_IN_PROGRESS state and set back to READY state when ended. This implies
that actions MUST NOT be run in parallel. </p>

<p>When connection is lost, a request MUST be put to DISCONNECTED state and
automatically reinitialized when connection is reestablished (as if the request
were newly instantiated). </p>

<p>A pending request MAY be canceled. Actual cancellation MAY be ignored, however
completion of the request MUST be always reported via request completion callback
mechanism.</p>

<p>A request MAY be destroyed any time (in any state) and then its state MUST
be set to DESTROYED. Once the request is destroyed, it MUST NOT be used
anymore. </p>

<h2 id="flowControl">Flow Control</h2>

<p>This section is <b>not</b> intended to be <a
 href="http://epics-pvdata.sourceforge.net/charter.html#normative">normative</a>. It
is given only to help developers write agents that implement pvAccess optimally with
 respect to monitoring. This
 section does 
not describe the protocol itself.</p>

<p>
A pvAccess implementation SHOULD implement flow control such that each endpoint
should try to send as much monitoring data as it can subject to an upper limit
calculated with respect to the amount of the other party's free receive buffer
size. Were this limit to be reached, monitors would start pilling up in the
monitors' circular buffer queues. </p>

<p style="font-style:italic;">Usually flow control algorithms wait for
congestion to occur before they are triggered. They are causal. However, due to
the isolated nature of TCP connection - there are always only two parties
involved - it is possible to predict congestions using the following algorithm:
</p>
<ul style="font-style:italic;">
  <li>Both parties exchange their receive socket and local buffer sizes</li>
  <li>Periodically, i.e. every N bytes, they send a control message marking the
    total number of bytes sent to the other party</li>
  <li>When the other party receives the control message it responds back with a
    complementary control message indicating the received marker value. This
    acknowledges the reception of total bytes sent</li>
  <li>The difference between total bytes sent and last acknowledged marker
    received tells how much other party receive buffers are full. This number
    should never exceed the total sum of receive buffer sizes.</li>
</ul>

<p style="font-style:italic;">Flow control is needed only to optimize
subscription messages back to the client (i.e. monitors). For other
messages TCP flow control is sufficient. </p>
<p style="font-style:italic;">
A pvAccess implementation SHOULD implement flow control such that each endpoint
should try to send as much monitoring data as it can subject to an upper limit
calculated with respect to the amount of the other party's free receive buffer
size. Were this limit to be reached, monitors would start pilling up in the
monitors' circular buffer queues. </p>

<h3 id="flowControlExample">Flow Control Example</h3>

<p style="font-style:italic;">The intention of flow control is to avoid having
the following behavior, which typically results from pure TCP flow control: </p>
<ul style="font-style:italic;">
  <li>Let's assume the client's Rx buffers are full</li>
  <li>The server is sending monitors until TCP detects the client's Rx buffer is
    full</li>
  <li>After some time the client's Rx buffer is immediately emptied. This is a
    consequence of the fact that 
     bulk reads are made from the socket rather than reads message by message (because OS calls
    are expensive)</li>
  <li>Server starts sending monitors until all the buffers are full (the server will
    fill all the buffers before the client actually processed received
  monitors!)</li>
</ul>

<p style="font-style:italic;">Such situations as described above would result
in monitors like the following (identified by their sequential number): </p>
<pre>0 1 2 3 4 (buffers full) 7 8 9 10 11 12 (buffers full) 22 23 24 25 26 27 28 (buffers full)</pre>

<p style="font-style:italic;">Flow control can make this better: </p>
<pre>0 1 2 3 4 (buffers full) 7 8 (buffers still full, but for less time since the server would send only as much as the client can handle) 10 11 (...) 14 15 (...) 18 19</pre>

<p style="font-style:italic;">The result is more fluid and up-to-date arrival
of monitors, which overcomes the combined problems of slow processing and
large buffers. </p>

<p>Requiring flow control (in addition to already
existing monitor queues) would add complexity to the protocol's implementation. It
needs to be decided whether the above flow control should be specified as part of the
normative specification, or only suggested non-normatively. At present, it is only suggested. </p>

<h2 id="channelDiscovery">Channel Discovery</h2>

<p>pvAccess uses a broadcast/multicast channel discovery mechanism using UDP;
search messages are usually sent to broadcast addresses and servers hosting
searched channels respond with a message containing their server address and
port.
In addition pvAccess transparently supports multicast, if an address is a
multicast address the implementation SHOULD transparently handle it. That is, it
should join the
multicast group in order to receive multicast messages.</p>

<p class="ed">Possible future addition: UDP congestion control should be
added to the specification to prevent the possibility of poor implementations flooding
a network with UDP search messages. Currently a
simple and robust algorithm is used in the reference implementation. The optimality
of the algorithm should to be verified and added to this specification. </p>

<h2 id="communicationExample">Communication Example</h2>

<p>
The following table illustrates messages sent between a client and a server where the client issues
a get request on a channel.
</p>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Communication Example.</caption>
  <tbody>
    <tr>
      <th>Server</th>
      <th></th>
      <th>Client</th>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>searchRequest (UDP broadcast/multicast)</td>
    </tr>
    <tr>
      <td>searchResponse (UDP unicast)</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td align="left" colspan="3">TCP/IP connection established</td>
    </tr>
    <tr>
      <td>setByteOrderControlMessage</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td>connectionValidationRequest</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>connectionValidationResponse</td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>createChannelRequest</td>
    </tr>
    <tr>
      <td>createChannelResponse</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>channelGetRequestInit</td>
    </tr>
    <tr>
      <td>channelGetResponseInit</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>channelGetRequest</td>
    </tr>
    <tr>
      <td>channelGetResponse</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>. . .</td>
    </tr>
    <tr>
      <td>. . .</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>destroyRequest</td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>channelDestroyRequest</td>
    </tr>
    <tr>
      <td>channelDestroyResponse</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
  </tbody>
</table>


<h2 id="protocolMessages">Protocol Messages</h2>

<p>The pvAccess protocol uses two protocol message types: </p>
<ul>
  <li>Control messages. These include flow control and have no payload</li>
  <li>Application messages. These are the requests and their responses.</li>
</ul>

<p>Each message consists of a message header and, optionally a message payload
that immediately follows the header. Messages MUST BE aligned on a 64-bit
boundary.</p>

<p>Every implementation of the protocol which purports to support this specification version of the
protocol, MUST also support all prior specification versions of the protocol. Every implementation
of the protocol MUST clearly indicate the most recent specification version to which it is
conformant, using the version URLs above.</p>

<h3 id="protocolMessages:messageHeader">Message Header</h3>

<p>Each protocol message has a fixed 8-byte header that MUST be encoded as if
it were expressed by the following structure: </p>
<pre>struct pvAccessHeader {
    byte magic;
    byte version;
    byte flags;
    byte messageCommand;
    int payloadSize;
};</pre>

<p>The semantics of these message header components are given in the following table.</p>
<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">pvAccess Header Members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">magic</td>
      <td>pvAccess protocol magic code. This MUST always be valued 0xCA.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">version</td>
      <td>Protocol version.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">flags</td>
      <td>Message flags.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">messageCommand</td>
      <td>Message command (i.e. create, get, put, process, etc.).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">payloadSize</td>
      <td>Message payload size (non-aligned, in bytes).</td>
    </tr>
  </tbody>
</table>



<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">pvAccess Header Flags Description.</caption>
  <tbody>
    <tr>
      <th>bit</th>
      <th>Value</th>
      <th>Description</th>
    </tr>
    <tr>
      <td rowspan="2" style="text-align:right;font-family:monospace">0</td>
      <td style="text-align:right;font-family:monospace">0</td>
      <td>Application message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">1</td>
      <td>Control message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">1,2,3</td>
      <td colspan="2">Unused, MUST be 0.</td>
    </tr>
    <tr>
      <td rowspan="4" style="text-align:right;font-family:monospace">5,4</td>
      <td style="text-align:right;font-family:monospace">00</td>
      <td>Not segmented message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">01</td>
      <td>First messsage (of set of segmented messages).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">10</td>
      <td>Last message (of set of segmented messages).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">11</td>
      <td>Middle message (of set of segmented messages).</td>
    </tr>
    <tr>
      <td rowspan="2" style="text-align:right;font-family:monospace">6</td>
      <td style="text-align:right;font-family:monospace">0</td>
      <td>Message sent by client.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">1</td>
      <td>Message sent by server.</td>
    </tr>
    <tr>
      <td rowspan="2" style="text-align:right;font-family:monospace">7</td>
      <td style="text-align:right;font-family:monospace">0</td>
      <td>Little endian byte order.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">1</td>
      <td>Big endian byte order.</td>
    </tr>
  </tbody>
</table>

<p>Between two segmented messages of the same set there MUST NOT be any other
application message than the segmented message of the same set. Control
messages are allowed to be in-between. </p>
<p>
Alignment offset MUST be preserved between segmented messages, i.e. if the last
sent byte of a segmented message is misaligned by 6 bytes to the 64-bit aligned 
start of the message reference point, then the next segmented message needs to insert
6 padding bytes at the start of the next segmented message payload.
</p>


<h2 id="protocolMessages:applicationMessages">Application Messages</h2>

<p>This section describes the message payloads for application messages. Each
subsection describes a single message command
(<i>pvAccessHeader.messageCommand</i>). </p>

<p>"request" means a message sent by a client, and "response" means a message sent
by a server. <span class="ed priv"> Is this specifically in response to the client request? If so,
as written "response" does not say that!</span></p>

<p>In order to understand specific application messages it is helpful to be familiar
with the EPICS V4 <a
 href="http://epics-pvdata.sourceforge.net/hgweb/pvAccessJava/raw-file/tip/documentation/pvAccessJava.html">pvAccess</a>
Programmers Reference.</p>

<p>Most application messages below relate to the management of process variable channels.
A process variable, or PV, is a dynamical quantity and its
associated local processing semantics, as understood by process control
systems. pvAccess has been designed to specifically integrate with process control
systems, particularly EPICS V4, to provide an efficient interconnect for systems
involved in the exchange of PV related information. Agent systems connect to a
process control computer (via pvAccess) hosting PVs, by opening a "Channel" to each
PV of interest. A channel is the temporal connection between 
pvAccess agents, with respect to one process variable. </p>

<p>All application message MUST be sent over the data transmission transport unless
explicitly specified. TCP/IP is the transport
in the reference implementation. A response message MUST
be sent over the same transport as that on which the request was received.</p>

<h3 id="protocolMessages:applicationMessages:beacon">Beacon (0x00)</h3>

<p>Servers MUST broadcast or multicast beacons over UDP. Beacons are be used to
announce new servers and server restarts. </p>
<pre>struct beaconMessage {
    short beaconSequenceId;
    long startupTimeSeconds;
    int startupTimeNanos;
    byte[16] serverAddressIPv6;
    short serverPort;
    string protocol;
    FieldDesc serverStatusIF;
    [if serverStatusIF != NULL_TYPE_CODE] PVField serverStatus;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Beacon Message Members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">beaconSequenceId</td>
      <td>Beacon sequence ID (counter w/ rollover). Can be used to detect UDP
        routing problems.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">startupTimeSeconds</td>
      <td>Server startup time (POSIX time).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">startupTimeNanos</td>
      <td>Server startup time (nanoseconds part).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverAddressIPv6</td>
      <td>Server IPv6 address (or IPv6 encoded IPv4 address).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverPort</td>
      <td>Server port (where server is listening).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">protocol</td>
      <td>Protocol name, "tcp" for standard pvAccess TCP/IP communication.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverStatusIF</td>
      <td>Optional server status Field description, NULL_TYPE_CODE MUST be used
        indicate absence of data.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverStatus</td>
      <td>Optional server data.</td>
    </tr>
  </tbody>
</table>

<p>When a pvAccess server is started it MUST start emitting beacons. Clients MUST monitor
all beacons. A beacon received from an as yet unknown serverAddressIPv6 serverPort
MUST be interpreted as indicating that
a new server has come online. A beacon with the same
serverAdddressIPv6:serverPort address as one already received but has different
startupTime{Seconds,Nanos}, MUST be interpreted as indicating that the server was
restarted. In both cases a
client SHOULD boost searching of not yet found channels. A client MAY disconnect
old connections or wait until connection loss is detected (on failed Echo
message send). </p>

<p>Each server transport instance SHOULD emit its own beacons. For example, if a server is
supporting data transmission over TCP/IP and UDP/IP then these SHOULD both emit
beacons. If the instances are tightly coupled, i.e. they have the same
lifecycle and share the same channels, then only one server MAY emit beacons.
</p>

<p>Servers SHOULD synchronize their internal clocks using NTP or some
other suitable time source before sending their first beacon.</p>

<p>Due to the fact that UDP does not guarantee delivery, a server MUST send
several beacons to notify that it is alive (e.g. 15 beacons with 1Hz period). After a
longer period it MAY stop sending them, however it is recommended that it
SHOULD continue merely with a low rate (e.g. one beacon per minute) to report
serverStatus.</p>

<p>Beacons SHOULD not used to report connection-valid status. </p>

<h3 id="protocolMessages:applicationMessages:connectionValidation">Connection
validation (0x01)</h3>

<p>A "connection validation" message MUST be first application message sent
from the server to a client when a TCP/IP connection is established. The
message indicates that the server is ready to receive requests. The client MUST
NOT send any messages on the connection until it has received a connection
validation message from the server. </p>

<p>The purpose of the connection validation message is two-fold: </p>
<ul>
  <li>It informs the client of the connection and protocol details</li>
  <li>It prevents the client from writing a request message to its local
    transport buffers until after the server has acknowledged that it can
    actually process the request. This avoids a race condition caused by the
    server's TCP/IP stack accepting connections in its backlog while the server
    is in the process of shutting down. If the client were to send a request in
    this situation, the request would be lost but the client could not safely
    reissue the request because that might violate at-most-once semantics.</li>
</ul>

<p>The connection validation message guarantees that a server is not in the
middle of shutting down when the server's TCP/IP stack accepts an incoming
connection, and so avoids the race condition. </p>

<p>The connection validation request and connection validation response messages are
defined as follows:</p>

<pre>struct connectionValidationRequest {
    int serverReceiveBufferSize;
    int serverReceiveSocketBufferSize;
    short serverIntrospectionRegistryMaxSize;
};

struct connectionValidationResponse {
    int clientReceiveBufferSize;
    int clientReceiveSocketBufferSize;
    short clientIntrospectionRegistryMaxSize;
    short connectionQos;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Connection Validation Request Message
  Members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td
      style="text-align:right;font-family:monospace">serverReceiveBufferSize</td>
      <td>Server receive buffer size in bytes.</td>
    </tr>
    <tr>
      <td
        style="text-align:right;font-family:monospace">serverReceiveSocketBufferSize</td>
      <td>Server socket buffer size in bytes.</td>
    </tr>
    <tr>
      <td
        style="text-align:right;font-family:monospace">serverIntrospectionRegistryMaxSize</td>
      <td>Maximum number of introspection registry entries server is able to
        handle.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Connection Validation Response Message
  Members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td
      style="text-align:right;font-family:monospace">clientReceiveBufferSize</td>
      <td>Client receive buffer size in bytes.</td>
    </tr>
    <tr>
      <td
        style="text-align:right;font-family:monospace">clientReceiveSocketBufferSize</td>
      <td>Client socket buffer size in bytes.</td>
    </tr>
    <tr>
      <td
        style="text-align:right;font-family:monospace">clientIntrospectionRegistryMaxSize</td>
      <td>Maximum number of introspection registry entries client is able to
        handle.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">connectionQoS</td>
      <td>Connection QoS parameters.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Connection QoS Parameters
  Description.</caption>
  <tbody>
    <tr>
      <th>bit</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">0-6</td>
      <td>Priority level [0-100].</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">7</td>
      <td>Unused, MUST be 0.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">8</td>
      <td>Low-latency priority.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">9</td>
      <td>Throughput priority.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">10</td>
      <td>Enable compression.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">11-15</td>
      <td>Unused, MUST be 0.</td>
    </tr>
  </tbody>
</table>

<p>Each Quality of Service (QoS) parameter value REQUIRES a separate TCP/IP connection. If the
Low-latency priority bit is set, this indicates clients should attempt to minimize
latency if they have the capacity to do so. If
the Throughput priority bit is set, this indicates a client similarly should attempt
to maximize throughput. How
this is achieved is implementation defined. The Compression bit enables
compression for the connection <span class="ed priv">Which compression? From
which support layer</span>. A matter for a future version of the specification should
be whether a streaming mode algorithm should be specified. </p>

<h3 id="protocolMessages:applicationMessages:echo">Echo (0x02)</h3>

<p>An Echo diagnostic message is usually sent to check if TCP/IP connection is
still valid. It can also be broadcast over UDP/IP to get list of all servers
in the subnet (note that UDP does not guarantee delivery). </p>
<pre>struct echoRequest {
    byte[] somePayload;
};

struct echoResponse {
    byte[] samePayloadAsInRequest;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Echo request message members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">somePayload</td>
      <td>Arbitrary payload content, can be empty.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Echo response message members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td
      style="text-align:right;font-family:monospace">samePayloadAsInRequest</td>
      <td>Same paylaod as in request message.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:searchRequest">Search request
(0x03)</h3>

<p>A channel "search request" message SHOULD be sent over UDP/IP, however UDP
congestion control SHOULD be implemented in this case. A server MUST accept this
message also over TCP/IP. </p>
<pre>        
struct searchRequest {
    int searchSequenceID;
    byte replyRequired;
    struct {
        int searchInstanceID;
        string channelName;
    } channels[];
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Search request message members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">searchSequenceID</td>
      <td>Search sequence ID (counter w/ rollover), can be used by congestion
        control algorithms.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">replyRequired</td>
      <td>0x01 to force server to respond even if it does not host channel(s),
        0x00 otherwise.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">searchInstanceID</td>
      <td>ID to be used to associate response with the following channel
      name.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">channelName</td>
      <td>Non-empty channel name, maximum length of 500 characters.</td>
    </tr>
  </tbody>
</table>

<p>The response to a search request is defined as messageCommand 0x04, see
below. </p>

<h3 id="protocolMessages:applicationMessages:searchResponse">Search response
(0x04)</h3>

<p>A "search response" message MUST be sent as the response to a search request
(0x03) message. </p>
<pre>struct searchResponse {
    int searchSequenceID;
    boolean found;
    byte[16] serverAddressIPv6;
    short serverPort;
    string protocol;
    int[] searchInstanceIDs;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Search response message members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">searchSequenceID</td>
      <td>Search sequence ID, same as specified in search request.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">found</td>
      <td>Flag indicating whether response contains IDs of found or not found
        channels.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverAddressIPv6</td>
      <td>Server IPv6 address (or IPv6 encoded IPv4 address).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverPort</td>
      <td>Server port (where server is listening).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">protocol</td>
      <td>Protocol name, "tcp" for standard pvAccess TCP/IP communication.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">searchInstanceIDs</td>
      <td>IDs, associated with names in the request, relevant to this
      response.</td>
    </tr>
  </tbody>
</table>

<p>A client MUST examine the protocol member field to verify it supports the given exchange
protocol; if not, the search response is ignored. </p>

<h3 id="protocolMessages:applicationMessages:createChannel">Create channel
(0x07)</h3>

<p>A channel provides a communication path beween a client and a server hosted
"process variable." </p>

<p>Each channel instance MUST be bound only to one
connection.
</p>

<pre>struct createChannelRequest {
    struct {
        int clientChannelID;
        string channelName;
    } channels[];
};

struct createChannelResponse {
    int clientChannelID;
    int serverChannelID;
    Status status;
    [if status.type == OK | WARNING] short accessRights;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Create channel request message
  members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">clientChannelID</td>
      <td>Client generated channel ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">channelName</td>
      <td>Name of the channel to be created, non-empty and maximum length of
        500 characters.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Create channel response (per channel)
  message members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">clientChannelID</td>
      <td>Client generated channel ID, same as in request</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">accessRights</td>
      <td>Access rights (TBD).</td>
    </tr>
  </tbody>
</table>

<p>NOTE: A server MUST store the clientChannelID and respond back with its
value in a destroyChannelMessage when channel destroy request is requested, see
below. A client uses the serverChannelID value for all subsequent requests on
the channel. Agents SHOULD NOT make any assumptions about how given IDs are
generated. IDs MUST be unique within a connection and MAY be recycled after a
channel is disconnected.</p>

<h3 id="protocolMessages:applicationMessages:destroyChannel">Destroy channel
(0x08)</h3>

<p>A "destroy channel" message is sent to a server to destroy a channel that
was previously created (with a create channel message). </p>
<pre>struct destroyChannelRequest {
    struct {
        int clientChannelID;
        int serverChannelID;
    } channels[];
};

struct destroyChannelResponse {
    struct {
        int clientChannelID;
        int serverChannelID;
        Status status;
    } channels[];
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Destroy channel request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">clientChannelID</td>
      <td>Client generated channel ID, same as in create request.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create response.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Destroy channel response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">clientChannelID</td>
      <td>Client generated channel ID, same as in create request.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>

<p>If the request (clientChannelID,
serverChannelID) pair does not match, the server MUST respond with an error
status. The server MAY break its response into several messages. 
</p>

<p>NOTE: A server MUST send this message to a client to notify the client about
server-side initiated channel destruction. Subsequently, a client MUST mark such
channels as disconnected. If the client's interest in the process variable continues,
it MUST start sending search request messages for the
channel.<br />
</p>

<h3 id="protocolMessages:applicationMessages:channelGet">Channel get (0x0A)</h3>

<p>A "channel get" set of messages are used to retrieve (get) data from the
channel. </p>
<pre>struct channelGetRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08 for INIT;
    FieldDesc pvRequestIF;
    PVField pvRequest;
};

struct channelGetResponseInit {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] FieldDesc pvStructureIF;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel get init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>pvRequest Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel get init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvStructureIF</td>
      <td>pvStructure (data container) Field description.</td>
    </tr>
  </tbody>
</table>

<p>After a get request is successfully initialized, the client can issue actual get
request(s). </p>
<pre>struct channelGetRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x40 for GET; additional 0x10 mask for DESTROY;
};

struct channelGetResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] BitSet changedBitSet;
    [if status.type == OK | WARNING] PVField pvStructureData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel get request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x40 for GET, additional 0x10 mask for DESTROY.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel get response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">changedBitSet</td>
      <td>Changed BitSet for pvStructureData.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvStructureData</td>
      <td>Data structure.</td>
    </tr>
  </tbody>
</table>

<p>NOTE: if the DESTROY mask is applied, the server MUST destroy request after get
response and the client MUST do the same after it receives the response. </p>

<h3 id="protocolMessages:applicationMessages:channelPut">Channel put (0x0B)</h3>

<p>A "channel put" set of messages are used to set (put) data to the channel.
</p>
<pre>struct channelPutRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08;
    FieldDesc pvRequestIF;
    PVField pvRequest;
};

struct channelPutResponseInit {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] FieldDesc pvPutStructureIF;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel put init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>pvRequest Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel put init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvPutStructureIF</td>
      <td>pvPutStructure (data container) Field description.</td>
    </tr>
  </tbody>
</table>

<p>After a put request is successfully initialized, the client can issue actual put
request(s) on the channel. </p>
<pre>struct channelPutRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x00 for PUT; 0x10 mask for DESTROY;
    BitSet toPutBitSet;
    PVField pvPutStructureData;
};

struct channelPutResponse {
    int requestID;
    byte subcommand;
    Status status;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel put request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x00 for PUT, additional 0x10 mask for DESTROY.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">toPutBitSet</td>
      <td>To-put BitSet for pvPutStructureData.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvPutStructureData</td>
      <td>Data to put structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel put response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>

<p>A "get-put" request retrieves the remote put structure. This MAY be used by user
applications to show data that were set last time by the application. </p>
<pre>struct channelGetPutRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x40;
};

struct channelGetPutResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] PVField pvPutStructureData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel get put request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x40.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel get put response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvPutStructureData</td>
      <td>Remote put data structure.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:channelPutGet">Channel put-get
(0x0C)</h3>

<p>A "channel put-get" set of messages are used to set (put) data to the
channel and then immediately retrieve data from the channel. Channels are usually
"processed" or "updated" by their host between put and get, so that the get reflects
changes in the process variable's state. </p>
<pre>struct channelPutGetRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08;
    FieldDesc pvRequestIF;
    PVField pvRequest;
};

struct channelPutGetResponseInit {
    int requestID;
    byte subcommand; 
    Status status;
    [if status.type == OK | WARNING] FieldDesc pvPutStructureIF;
    [if status.type == OK | WARNING] FieldDesc pvGetStructureIF;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel put-get init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>pvRequest Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel put-get init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvPutStructureIF</td>
      <td>pvPutStructure (data container) Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvGetStructureIF</td>
      <td>pvGetStructure (data container) Field description.</td>
    </tr>
  </tbody>
</table>

<p>After a put-get request is successfully initialized, the client can issue actual
put-get request(s) on the channel. </p>
<pre>struct channelPutGetRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x00 for PUT_GET; 0x10 mask for DESTROY;
    BitSet toPutBitSet;
    PVField pvPutStructureData;
};

struct channelPutGetResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] PVField pvGetStructureData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel put-get request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x00 for PUT_GET, additional 0x01 mask for DESTROY.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">toPutBitSet</td>
      <td>To-put BitSet for pvPutStructureData.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvPutStructureData</td>
      <td>Data to put structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel put-get response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvGetStructureData</td>
      <td>Get data structure.</td>
    </tr>
  </tbody>
</table>

<p>A "get-put" request retrieves the remote put structure. This MAY be used by user
applications to show data that were set last time by the application. </p>
<pre>struct channelGetPutRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x80;
};

struct channelGetPutResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] PVField pvPutStructureData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel get put request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x80.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel get put response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvPutStructureData</td>
      <td>Remote put data structure.</td>
    </tr>
  </tbody>
</table>

<p>A "get-get" request retrieves remote get structure. This MAY be used by user
applications to show data that were retrieved last time. </p>
<pre>struct channelGetGetRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x40;
};

struct channelGetGetResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] PVField pvGetStructureData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel get get request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x40.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel get get response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvGetStructureData</td>
      <td>Remote get data structure.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:channelMonitor">Channel monitor
(0x0D)</h3>

<p>The "channel monitor" set of messages are used to by client agents to indicate
that they wish to be asynchronously informed of changes in the state or values of the
process variable of a
channel. The subscribe mechanism is employed. </p>
<pre>struct channelMonitorRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08;
    FieldDesc pvRequestIF;
    PVField pvRequest;
};

struct channelMonitorResponseInit {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] FieldDesc pvStructureIF;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel monitor init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>pvRequest Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel monitor init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvStructureIF</td>
      <td>pvStructure (data container) Field description.</td>
    </tr>
  </tbody>
</table>

<p>The pvRequest structure SHOULD be used to specify monitor queue size and
algorithm. How it may be used for those functions is not defined by pvAccess,
and so would be implementation defined. </p>

<p>After monitor request is successfully initialized, the client can issue actual
monitor request(s). </p>

<p>The following messages MUST be used to start (resume) or stop (suspend)
monitoring and to destroy monitor request (subscription): </p>
<pre>struct channelStartMonitorRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x44;
};</pre>
<pre>struct channelStopMonitorRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x04;
};</pre>
<pre>struct channelDestroyMonitorRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x10;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel monitor requests.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x44 for START, 0x04 for STOP, 0x10 for DESTROY.</td>
    </tr>
  </tbody>
</table>

<p>The response for monitor requests above has the following form: </p>
<pre>struct channelMonitorResponse {
    int requestID;
    byte subcommand = 0x00;
    BitSet changedBitSet;
    PVField pvStructureData;
    BitSet overrunBitSet;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel monitor response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in monitor init request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x00.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">changedBitSet</td>
      <td>Changed BitSet for pvStructureData.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvStructureData</td>
      <td>Data structure.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">overrunBitSet</td>
      <td>BitSet indicating overrun fields.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:channelArray">Channel array
(0x0E)</h3>

<p>A "channel array" set of messages are used to handle remote array values. Requests
allow a client agent to: retrieve (get) and set (put) data from/to the array, and
to change the array's length (number of valid elements in the array). </p>
<pre>struct channelArrayRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08;
    FieldDesc pvRequestIF;
    PVField pvRequest;
};

struct channelArrayResponseInit {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] FieldDesc pvArrayIF;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel array init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>pvRequest Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel array init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvArrayIF</td>
      <td>pvArray (data container) Field description.</td>
    </tr>
  </tbody>
</table>

<p>After an array request is successfully initialized, the client can issue actual
array request(s). </p>
<pre>struct channelGetArrayRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x40 mask for GET; 0x10 mask for DESTROY;
    size offset;
    size count;
};

struct channelGetArrayResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] PVField pvArrayData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel array get request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x40 for GET, additional 0x10 mask for DESTROY.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">offset</td>
      <td>Offset from the beginning of the array.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">count</td>
      <td>Number of elements requested, 0 means form offset to the end of the
        array.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel array get response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvArrayData</td>
      <td>Data array.</td>
    </tr>
  </tbody>
</table>
<pre>struct channelPutArrayRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x00 mask for PUT; 0x10 mask for DESTROY;
    size offset;
    PVField pvArrayData;
};

struct channelPutArrayResponse {
    int requestID;
    byte subcommand;
    Status status;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel array put request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x00 for PUT, additional 0x10 mask for DESTROY.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">offset</td>
      <td>Offset from the beginning of the array.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvArrayData</td>
      <td>Subarray to be put.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel array put response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>

/// TODO GetLength is missing, fix the codes !!!

<pre>struct channelSetLengthRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x80 mask for SET_LENGTH; 0x10 mask for DESTROY;
    size length;
};

struct channelSetLengthResponse {
    int requestID;
    byte subcommand;
    Status status;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel array set length request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x40 for GET, additional 0x10 mask for DESTROY.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">length</td>
      <td>New length.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel array set length response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:destroyRequest">Destroy request
(0xF)</h3>

<p>A "destroy request" messages is used destroy any request instance, i.e. an
instance with requestID. </p>
<pre>// destroys any request with given requestID
struct destroyRequest {
    int serverChannelID;
    int requestID;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Destroy request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request init message.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:channelProcess">Channel process
(0x10)</h3>

<p>A "channel process" set of messages are used to indicate to the server that the
computation actions associated with a 
channel should be executed. That is in the language of EPICS, the channel should be "processed".
</p>
<pre>struct channelProcessRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08;
    FieldDesc pvRequestIF;
    [if serverStatusIF != NULL_TYPE_CODE] PVField pvRequest;
};

struct channelProcessResponseInit {
    int requestID;
    byte subcommand;
    Status status;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel process init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>Optional pvRequest Field description, NULL_TYPE_CODE is none.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>Optional pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel process init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>

<p>After a process request is successfully initialized, the client can issue actual
process request(s). </p>

<pre>struct channelProcessRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x00 mask for PROCESS; 0x10 mask for DESTROY;
};

struct channelProcessResponse {
    int requestID;
    byte subcommand;
    Status status;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel proces request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x00 for PROCESS, additional 0x10 mask for DESTROY.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel process response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:channelGetField">Get channel type
introspection data (0x11)</h3>

<p>A "get channel type introspection data" messages is used to retrieve a channel's
type introspection data, i.e. a description of all the channel's fields and their
data types. </p>
<pre>struct channelGetFieldRequest {
    int serverChannelID;
    int requestID;
    string subFieldName;  // entire record if empty
};

struct channelGetFieldResponse {
    int requestID;
    Status status;
    [if status.type == OK | WARNING] FieldDesc subFieldIF;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Get channel introspection data
  request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subFieldName</td>
      <td>Name of the subfield to get or entire record if empty.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Get channel introspection data
  response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subFieldIF</td>
      <td>Requested field introspection data.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:message">Message (0x12)</h3>

<p>A "message" message is used by a server to provide to a client human readable
text regarding the status of a specific request. This message MUST NOT be used to report
request completion status. </p>
<pre>struct message {
    int requestID;
    byte messageType; // info = 0, warning = 1, error = 2, fatalError = 3
    string message;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Message response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">messageType</td>
      <td>Message type enum.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">message</td>
      <td>Message.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:channelRPC">Channel RPC (0x14)</h3>

<p>The "channel RPC" set of messages are used to provide remote procedure call
(RPC) support over pvAccess. </p>
<pre>struct channelRPCRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08;
    FieldDesc pvRequestIF;
    PVField pvRequest;
};

struct channelRPCResponseInit {
    int requestID;
    byte subcommand;
    Status status;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel RPC init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>pvRequest Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel RPC init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>

<p>After a RPC request is successfully initialized, the client can issue actual RPC
request(s). </p>
<pre>struct channelRPCRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x00 mask for RPC; 0x10 mask for DESTROY;
    FieldDesc pvStructureIF;
    PVField pvStructureData;
};

struct channelRPCResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] FieldDesc pvResponseIF;
    [if status.type == OK | WARNING] PVField pvResponseData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel RPC request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x00 for RPC, additional 0x10 mask for DESTROY.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvStructureIF</td>
      <td>pvStructureData Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvStructureData</td>
      <td>Argument data structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Channel RPC response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvResponseIF</td>
      <td>pvResponseDataField description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvResponseData</td>
      <td>Response data structure.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:cancelRequest">Cancel request
(0x15)</h3>

<p>A "cancel request" messages is used cancel any pending request, i.e. an
instance with requestID. </p>
<pre>// cancel any request with given requestID
struct cancelRequest {
    int serverChannelID;
    int requestID;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Cancel request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request init message.</td>
    </tr>
  </tbody>
</table>

<h2 id="controlMessages">Control Messages</h2>

<p>This section describes the message payloads for control messages. Each
subsection describes a single message command
(<i>pvAccessHeader.messageCommand</i>). </p>

<p>Control messages have no payload and are used internally by the
protocol, for instance to handle byte order management and flow control.</p>

<p>The payload size field contains
control message specific values. </p>

<h3 id="protocolMessages:controlMessages:mark">Mark Total Byte Sent (0x00)</h3>

<p>Payload size field holds the value of total bytes sent. The client should
respond with acknowledgment control message (0x01) as soon as possible. </p>

<h3 id="protocolMessages:controlMessages:ackMark">Acknowledge Total Bytes
Received (0x01)</h3>

<p>Payload size field holds the acknowledge value of total bytes received. This must
match the previously received marked value as described above. </p>

<h3 id="protocolMessages:controlMessages:endianess">Set byte order (0x02)</h3>

<p>The 7-th bit of a header flags field indicates the server's selected byte order for
the connection on which this message was received.
Client MUST encode all the messages sent via this connection using this byte
order. <br />
The client's decoding byte order depends on payload size field value as follows: </p>

<table style="caption-side:bottom">
  <caption style="font-weight:bold; padding:1em">Client Decoding</caption>
  <tbody>
    <tr>
      <th>Payload Size Field Value</th>
      <th>Meaning</th>
    </tr>
    <tr>
      <td style="font-family:monospace">0x00000000</td>
      <td>Client MUST decode all the messages received via this connection
        using server's selected byte order.</td>
    </tr>
    <tr>
      <td style="font-family:monospace">0xFFFFFFFF</td>
      <td>Client MUST decode all the messages sent received this connection as
        indicated by each message byte order flag.</td>
    </tr>
  </tbody>
</table>

<p>This MUST be the first message sent by a server when connection is
established. For connection-less protocols this message is not sent and byte
order is determined per message using its byte order flag. </p>

<p>NOTE: this message is byte order independent. </p>

<h3 id="protocolMessages:controlMessages:echoRequest">Echo request (0x03)</h3>

<p>Diagnostic/test echo message. Receiver should respond with Echo response
(0x04) message with the same payload size field value. </p>

<h3 id="protocolMessages:controlMessages:echoResponse">Echo response (0x04)</h3>

<p>Response to a echo request. Payload size field contains the same value as in
request message. </p>

<h2 id="futureProtocolChanges">Future Protocol Changes/Updates</h2>

<p>The following are known items that should be specified in future revisions:
</p>
<ul>
  <li>"one-phase" get/put/get-put/process</li>
  <li>immutable fields support, cache implemented for values (useful for
  enums)</li>
  <li>optimized packed Monitor responses</li>
  <li>bulk message transfer/trottle public API</li>
  <li>access rights</li>
  <li>etc.</li>
</ul>

<h2 id="missing">Missing Aspects</h2>

<p>The following aspects are missing in the current revision of the specification and will be specified in future revisions:
</p>
<ul>
  <li>structure/content of pvRequestIF/pvRequest fields</li>
  <li>offset and count fields of channelArray request should be of type 'size', however 'size' cannot be negative</li>
  <li>update Communication Example section to show messages</li>
  <li>show example of array serialization that needs padding</li>
</ul>

<h2>Bibliography</h2>
<dd>
  <dt id="bib:caref" class="bib">bib:caref</dt>
  <dd>EPICS R3.14 Channel Access Reference Manual, J.O. Hill, R. Lange, 2002,
    <a href="http://www.aps.anl.gov/epics/base/R3-14/8-docs/CAref.html" >http://www.aps.anl.gov/epics/base/R3-14/8-docs/CAref.html</a>
    </dd>
    <dt id="bib:pvdatarefcpp" class="bib">bib:pvdatarefcpp</dt>
  <dd>EPICS pvDataCPP [pvData C++ Programmers Reference Manual], M. Kraimer, 2011 under
    development,
<a href="http://epics-pvdata.sourceforge.net/hgweb/pvDataCPP/raw-file/tip/documentation/pvDataCPP.html" >http://epics-pvdata.sourceforge.net/hgweb/pvDataCPP/raw-file/tip/documentation/pvDataCPP.html</a>
    </dd>
    <dt id="bib:pvdatarefjava" class="bib">bib:pvdatarefjava</dt>
  <dd>EPICS pvDataJava [pvData Java Programmers Reference Manual], M. Kraimer, 2011 under
    development,
<a href="http://epics-pvdata.sourceforge.net/hgweb/pvDataJava/raw-file/tip/documentation/pvDataJava.html" >http://epics-pvdata.sourceforge.net/hgweb/pvDataJava/raw-file/tip/documentation/pvDataJava.html</a>    
    </dd>
     <dt id="bib:ieee754wiki" class="bib">bib:ieee754wiki</dt>
       <dd>IEEE 754-2008, Wikipedia article, April 2012, <a href="http://en.wikipedia.org/wiki/IEEE_754-1985">http://en.wikipedia.org/wiki/IEEE_754-1985</a></dd>
</div>

</body>
</html>
