<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="keywords"
  content="EPICS, EPICSv4, pvAccess, specification, protocol, network, CAv4" />
  <title>pvAccess Protocol Specification</title>
  <link rel="stylesheet" type="text/css" href="base.css" />
  <link rel="stylesheet" type="text/css" href="epicsv4.css" />
  <style type="text/css">
/*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
/*]]>*/</style>
</head>

<body>

<div class="head">
<h1>pvAccess Protocol Specification</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date.  -->

<h2 class="nocount" id="L50">EPICS v4 Working Group, Second Public Working
Draft, 16-Jan-2012</h2>
<dl>
  <dt>This version:</dt>
    <dd><a
      href="http://epics-pvdata.sourceforge.net/pvAccess_Protocol_Specification_20120109.html">pvAccess_Protocol_Specification_20120116.html</a></dd>
  <dt>Latest version:</dt>
    <dd><a
      href="http://epics-pvdata.sourceforge.net/pvAccess_Protocol_Specification.html">pvAccess_Protocol_Specification.html</a></dd>
  <dt>Editors:</dt>
    <dd>Matej Sekoranja, Cosylab</dd>
    <dd>Greg White, SLAC, PSI</dd>
</dl>
<hr />
</div>

<h2 class="nocount" id="abstract">Abstract</h2>

<p>This document defines the EPICS V4 communication protocol called "pvAccess."
pvAccess is a high-performance network communication protocol for signal
monitoring and scientific data services interconnect. It is designed to support
the structured data types of the EPICS V4 "shared memory" data exchange system
called pvData, for optimized interoperability of control system endpoints. It
is a successor of EPICS Channel Access. </p>

<p>The connection setup requirements and individual message constructs of
pvAccess are described. It is intended that sufficient detail is given for a
reader to create an interoperable pvAccess implementation. A reference
implementation is being created by the EPICS V4 Working Group. </p>

<p>For more information about the EPICS, please refer to the home page of the
<a href="http://www.aps.anl.gov/epics/">Experimental Physics and Industrial
Control System.</a></p>

<h2 class="nocount" id="status">Status of this Document</h2>
<!-- Statement about why this version exists -->

<p>This is the 16 January 2012 version of the pvAccess Protocol Specification.
This version is an editors draft towards the Second Public Working Draft. The
Second Public Working Draft will be intended for the EPICS community to review and comment.
Resulting comments will drive subsequent revisions of the specification and the
EPICS V4 Working Group's reference implementation.</p>

<p>The present implementation of pvAccess largely reflects the specification as
written here. Another document will soon be written to track the status of the
reference implementation with respect to the specification, showing what has
yet to be implemented. </p>
<!-- Please always include this statement of terms, unless it's really silly -->

<p>The terms MUST, MUST NOT, SHOULD, SHOULD NOT, REQUIRED, and MAY when
highlighted (through style sheets, and in uppercase in the source) are used in
accordance with <a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a> [<a
href="refs.html#ref-RFC2119">RFC2119</a>]. The term NOT REQUIRED (not defined
in RFC 2119) indicates exemption. </p>
<!--NewPage-->
<!-- this is for html2ps -->

<h2 id="toc">Table of Contents</h2>
<div class="toc">
<ul>
  <li><a href="#overview">Overview</a></li>
  <li><a href="#dataEncoding">Data Encoding</a>
    <ul>
      <li><a href="#dataEncoding:sizes">Sizes</a></li>
      <li><a href="#dataEncoding:basicTypes">Basic Types</a></li>
      <li><a href="#dataEncoding:strings">Strings</a></li>
      <li><a href="#dataEncoding:arrays">Arrays</a></li>
      <li><a href="#dataEncoding:bitSets">BitSets</a></li>
      <li><a href="#dataEncoding:status">Status</a></li>
      <li><a href="#dataEncoding:introspectionData">Introspection Data</a>
        <ul>
          <li><a href="#dataEncoding:example">Example</a></li>
        </ul>
      </li>
      <li><a href="#dataEncoding:data">Data</a>
        <ul>
          <li><a href="#data:example1">Example #1</a></li>
          <li><a href="#data:example2">Example #2</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#connectionManagement">Connection Management</a></li>
  <li><a href="#channelLifecycle">Channel Life-cycle</a></li>
  <li><a href="#channelRequestLifecycle">Channel Request Life-cycle</a></li>
  <li><a href="#flowControl">Flow Control</a>
    <ul>
      <li><a href="#flowControlExample">Flow Control Example</a></li>
    </ul>
  </li>
  <li><a href="#channelDiscovery">Channel Discovery</a></li>
  <li><a href="#protocolMessages">Protocol Messages</a>
    <ul>
      <li><a href="#protocolMessages:messageHeader">Message header</a></li>
    </ul>
  </li>
  <li><a href="#protocolMessages:applicationMessages">Application Messages</a>
    <ul>
      <li><a href="#protocolMessages:applicationMessages:beacon">Beacon
        (0x00)</a></li>
      <li><a
        href="#protocolMessages:applicationMessages:connectionValidation">Connection
        validation (0x01)</a></li>
      <li><a href="#protocolMessages:applicationMessages:echo">Echo
      (0x02)</a></li>
      <li><a href="#protocolMessages:applicationMessages:searchRequest">Search
        request (0x03)</a></li>
      <li><a href="#protocolMessages:applicationMessages:searchResponse">Search
        response (0x04)</a></li>
      <li><a href="#protocolMessages:applicationMessages:createChannel">Create
        channel (0x07)</a></li>
      <li><a
        href="#protocolMessages:applicationMessages:destroyChannel">Destroy
        channel (0x08)</a></li>
      <li><a href="#protocolMessages:applicationMessages:channelGet">Channel
        get (0x0A)</a></li>
      <li><a href="#protocolMessages:applicationMessages:channelPut">Channel
        put (0x0B)</a></li>
      <li><a href="#protocolMessages:applicationMessages:channelPutGet">Channel
        put-get (0x0C)</a></li>
      <li><a
        href="#protocolMessages:applicationMessages:channelMonitor">Channel
        monitor (0x0D)</a></li>
      <li><a href="#protocolMessages:applicationMessages:channelArray">Channel
        array (0x0E)</a></li>
      <li><a
        href="#protocolMessages:applicationMessages:destroyRequest">Destroy
        request (0xF)</a></li>
      <li><a
        href="#protocolMessages:applicationMessages:channelProcess">Channel
        process (0x10)</a></li>
      <li><a href="#protocolMessages:applicationMessages:channelGetField">Get
        channel type introspection data (0x11)</a></li>
      <li><a href="#protocolMessages:applicationMessages:message">Message
        (0x12)</a></li>
      <li><a href="#protocolMessages:applicationMessages:channelRPC">Channel
        RPC (0x14)</a></li>
    </ul>
  </li>
  <li><a href="#controlMessages">Control Messages</a>
    <ul>
      <li><a href="#protocolMessages:controlMessages:mark">Mark Total Byte Sent
        (0x00)</a></li>
      <li><a href="#protocolMessages:controlMessages:ackMark">Acknowledge Total
        Bytes Received (0x01)</a></li>
      <li><a href="#protocolMessages:controlMessages:endianess">Announce
        byte-order (0x02)</a></li>
      <li><a href="#protocolMessages:controlMessages:echoRequest">Echo request
        (0x03)</a></li>
      <li><a href="#protocolMessages:controlMessages:echoResponse">Echo
        response (0x04)</a></li>
    </ul>
  </li>
  <li><a href="#communicationExample">Communication Example</a></li>
  <li><a href="#futureProtocolChanges">Future Protocol Changes/Updates</a></li>
</ul>
</div>

<h2 id="overview">Overview</h2>

<p>pvAccess is a high-performance network communication protocol. It is
primarily designed for efficient signal monitoring and the data requirements of
a service oriented architecture. It is a successor of of EPICS Channel Access.
</p>

<p>TCP/IP is used for data transmission, UDP/IP is normally used for discovery,
although discovery over TCP/IP is also allowed. The discovery mechanism allows
usage of other implementations (e.g. UDP/IP for data transmission). The
protocol itself supports IPv6, i.e. all addresses are IPv6 encoded. </p>

<p>Port numbers 5075 (tcp connection port) and 5076 (udp broadcast port) are
used (to be accepted by IANA). The default connection port SHOULD be used if
free, otherwise a dynamically allocated port SHOULD be used as a fallback. </p>

<p>pvAccess heavily depends on <a
href="http://epics-pvdata.sourceforge.net/">pvData</a> [<a
href="http://epics-pvdata.sourceforge.net/">pvData homepage</a>]. All data MUST
be sent as pvData objects. The protocol aims to send the minimum number of bits
necessary to inform peers of changes in endpoint data values subject to performance
considerations. That is, it combines CPU and wire data size considerations to
optimise overall control network throughput.
pvAccess supports segmented messages and thus allows the sending of large
amounts of data using optimal buffer sizing.
The maximum message size is not limited with respect
to the send or receive buffer sizes. </p>

<p>The pvAccess protocol definition consists of three major parts:</p>
<ul>
  <li>A set of data encoding rules that determine how the various data types
    are encoded and deserialized</li>
  <li>A set of rules that determine how client and server agree on a particular
    encoding</li>
  <li>A number of message types, that define the interchange between clients
    and servers, together with rules which specify what message is to be sent
    under what circumstances.</li>
</ul>

<h2 id="dataEncoding">Data Encoding</h2>

<p>The goals of the pvData data encoding are simplicity and efficiency. In
keeping with these goals, the encoding does not align primitive types on word
boundaries and therefore eliminates the wasted space and additional complexity
that alignment requires. The pvAccess data encoding simply produces a stream of
contiguous bytes; data MUST NOT contain padding bytes and MUST NOT be
aligned on word boundaries.<br />
However, array encoding is an exception. All arrays MUST be aligned to 64-bit
boundaries (the first element of each array is padded). The message header MUST
also be 64-bit aligned. </p>

<p>For connection-oriented communication (TCP/IP), the server MUST REQUIRE that
the client uses the server's byte order. Each message contains an endiannes
flag in order to allow all the
intermediates to forward data without requiring it to be unmarshaled (so that
the intermediates can forward requests by simply copying blocks of binary
data) and in order not to require a specific byte-order for connection-less
protocols (UDP). </p>

<h3 id="dataEncoding:sizes">Sizes</h3>

<p>Many of the types involved in the data encoding, as well as several protocol
message components, have an associated size (or "count"). Size values MUST
always be a non-negative number and encoded as follows: </p>
<ol>
  <li>If the number of elements is less than 255, the size MUST be encoded as a
    single byte containing an unsigned 8-bit integer indicating the number of
    elements</li>
  <li>If the number of elements is greater than or equal to 255, then the size
    MUST be encoded as a byte with value 255, followed by a positive signed
    32-bit integer indicating the number of elements. This implies maximum size
    of 2^31-1.</li>
</ol>

<p>Using this encoding to indicate size is significantly cheaper than always
using a 32-bit integer to store the size. This is especially true when
marshalling sequences of short strings; counts of up to 254 require only a
single byte instead of four. This comes at the expense of counts greater than
254, which require five bytes instead of four. However, for sequences or
strings of length greater than 254, the extra byte is insignificant. </p>

<h3 id="dataEncoding:basicTypes">Basic Types</h3>

<p>The basic types MUST be encoded as shown in Table 1. Integer types (byte,
short, int, long) MUST be represented as twoâ€™s complement numbers. Floating
point types (float, double) MUST use the IEEE-754 standard formats [<a
href="http://en.wikipedia.org/wiki/IEEE_754-1985">IEEE_754-1985 Wiki</a>]. </p>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Encoding for basic types.</caption>
  <tbody>
    <tr>
      <th>Type</th>
      <th>Encoding</th>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">boolean</td>
      <td>A single byte with value non-zero value for true, 0 for false.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">byte</td>
      <td>Signed 8-bit integer.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">short</td>
      <td>Signed 16-bit integer.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">int</td>
      <td>Signed 32-bit integer.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">long</td>
      <td>Signed 64-bit integer.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">float</td>
      <td>32-bit float (IEEE-754 single-precision float).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">double</td>
      <td>64-bit float (IEEE-754 double-precision float).</td>
    </tr>
  </tbody>
</table>

<p>Unsigned integers are not supported. </p>

<h3 id="dataEncoding:strings">Strings</h3>

<p>Strings MUST be encoded as a size, followed by the string contents in a
UTF-8 format array of bytes. Size gives the number of bytes that follow it and
not the number of UTF-8 characters. An empty string MUST be encoded with a size
of zero. <br />
Strings MUST NOT be NULL-terminated and MUST NOT contain a zero byte. NULL
strings are not supported. </p>

<p>On the wire, pvAccess MUST transmit all strings as Unicode strings in UTF-8.
Non-C++ bindings of the pv normative implementations (pvAccess and pvData in
particular) SHOULD use strings in their language-native Unicode representation
and convert automatically to and from UTF-8 for transmission, so applications
can transparently use characters from non-English alphabets. However, for C++,
how strings are represented inside a process depends on the platform as well as
the mapping that is chosen for a particular string. The default mapping to is
std::string. </p>

<h3 id="dataEncoding:arrays">Arrays</h3>

<p>Arrays MUST be encoded as a size representing the number of elements in the
array, followed by the elements encoded as specified for their type (as specified in these sections). </p>

<h3 id="dataEncoding:bitSets">BitSets</h3>

<p>BitSet is a pvData internal data type that represents an ordered set of bits. </p>

<p>For performance reasons BitSet implementation SHOULD store bits as 64-bit integers,
however serialization is size optimized and REQUIRES to send only least
possible number of bytes that encode all the bits in the set.<br />
A bitSet holding n bits is encoded as: </p>
<ul>
  <li>number of bytes needed to serialize BitSet: size type containing value of
    S = ceil(n/8)</li>
  <li>L 64-bit integers containing first 64-multiple of bits (LSB to MSB), integers are
    encoded in currently selected byte order, L = floor((n+7)/64)</li>
  <li>B bytes containing remaining bits in LSB to MSB order: B = S - 8*L</li>
</ul>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Example of how BitSet is encoded.</caption>
  <tbody>
    <tr>
      <th># bits</th>
      <th>S</th>
      <th>L</th>
      <th>B</th>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">7</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">8</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">15</td>
      <td>2</td>
      <td>0</td>
      <td>2</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">63</td>
      <td>8</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">64</td>
      <td>8</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td style="text-align:right;font-weight:bold">65</td>
      <td>9</td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>Examples of BitSet serialization (big-endian byte order): </p>
<pre>Hexdump [{}] size = 1
00                                                 .

Hexdump [{0}] size = 2
01 01                                              ..

Hexdump [{1}] size = 2
01 02                                              ..

Hexdump [{7}] size = 2
01 80                                              ..

Hexdump [{8}] size = 3
02 00 01                                           ...

Hexdump [{15}] size = 3
02 00 80                                           ...

Hexdump [{63}] size = 9
08 80 00 00  00 00 00 00  00                       .... .... .

Hexdump [{64}] size = 10
09 00 00 00  00 00 00 00  00 01                    .... .... ..

Hexdump [{65}] size = 10
09 00 00 00  00 00 00 00  00 02                    .... .... ..

Hexdump [{0, 1, 2, 4}] size = 2
01 17                                              ..

Hexdump [{0, 1, 2, 4, 8}] size = 3
02 17 01                                           ...

Hexdump [{8, 17, 24, 25, 34, 40, 42, 49, 50}] size = 8
07 00 01 02  03 04 05 06                            .... .... 

Hexdump [{8, 17, 24, 25, 34, 40, 42, 49, 50, 56, 57, 58}] size = 9
08 07 06 05  04 03 02 01  00                       .... .... .

Hexdump [{8, 17, 24, 25, 34, 40, 42, 49, 50, 56, 57, 58, 67}] size = 10
09 07 06 05  04 03 02 01  00 08                    .... .... ..

Hexdump [{8, 17, 24, 25, 34, 40, 42, 49, 50, 56, 57, 58, 67, 72, 75}] size = 11
0A 07 06 05  04 03 02 01  00 08 09                 .... .... ...

Hexdump [{8, 17, 24, 25, 34, 40, 42, 49, 50, 56, 57, 58, 67, 72, 75, 81, 83}] size = 12
0B 07 06 05  04 03 02 01  00 08 09 0A               .... .... .... </pre>

<h3 id="dataEncoding:status">Status</h3>

<p>pvAccess defines a structure to inform endpoints about completion status. It
is nominally defined as: </p>
<pre>struct Status {
    byte type;      // enum { OK = 0, WARNING = 1, ERROR = 2, FATAL = 3 }
    string message;
    string stackDump;   // optional (provides more context data about the error), can be empty
};</pre>

<p>OK and WARNING type mean success. </p>

<p>In practice, since the majority of Status instances would be OK with no
message and no stackDump, a special definition of Status SHOULD be used in the
common case that all three of these conditions are met. If Status would be OK
and no message and no stackDump are to be sent, then the special type value
<code>-1</code> is used and string fields are omitted: </p>
<pre>struct StatusOK {
    byte type = -1;
};</pre>

<p>NOTE: a decision was made not to use a potentially large set of hardcoded
error codes (enum), covering predicted issues. Rather, Status uses a short
summary error "type" code, and permits any status message. This allows Status
to express problems precisely, and avoids book-keeping problems. </p>

<p>Examples of Status serialization: </p>
<pre>Hexdump [Status OK] size = 1
FF                                                 .

Hexdump [WARNING, "Low memory", ""] size = 13
01 0A 4C 6F  77 20 6D 65  6D 6F 72 79  FF          ..Lo w me mory .

Hexdump [ERROR, "Failed to get, due to unexpected exception", (stack dump)] size = 264
01 2A 46 61  69 6C 65 64  20 74 6F 20  67 65 74 2C  .*Fa iled  to  get, 
20 64 75 65  20 74 6F 20  75 6E 65 78  70 65 63 74   due  to  unex pect 
65 64 20 65  78 63 65 70  74 69 6F 6E  DB 6A 61 76  ed e xcep tion .jav 
61 2E 6C 61  6E 67 2E 52  75 6E 74 69  6D 65 45 78  a.la ng.R unti meEx 
63 65 70 74  69 6F 6E 0A  09 61 74 20  6F 72 67 2E  cept ion. .at  org. 
65 70 69 63  73 2E 63 61  2E 63 6C 69  65 6E 74 2E  epic s.ca .cli ent. 
65 78 61 6D  70 6C 65 2E  53 65 72 69  61 6C 69 7A  exam ple. Seri aliz 
61 74 69 6F  6E 45 78 61  6D 70 6C 65  73 2E 73 74  atio nExa mple s.st 
61 74 75 73  45 78 61 6D  70 6C 65 73  28 53 65 72  atus Exam ples (Ser 
69 61 6C 69  7A 61 74 69  6F 6E 45 78  61 6D 70 6C  iali zati onEx ampl 
65 73 2E 6A  61 76 61 3A  31 31 38 29  0A 09 61 74  es.j ava: 118) ..at 
20 6F 72 67  2E 65 70 69  63 73 2E 63  61 2E 63 6C   org .epi cs.c a.cl 
69 65 6E 74  2E 65 78 61  6D 70 6C 65  2E 53 65 72  ient .exa mple .Ser 
69 61 6C 69  7A 61 74 69  6F 6E 45 78  61 6D 70 6C  iali zati onEx ampl 
65 73 2E 6D  61 69 6E 28  53 65 72 69  61 6C 69 7A  es.m ain( Seri aliz 
61 74 69 6F  6E 45 78 61  6D 70 6C 65  73 2E 6A 61  atio nExa mple s.ja 
76 61 3A 31  32 36 29 0A                            va:1 26). </pre>

<h3 id="dataEncoding:introspectionData">Introspection Data</h3>

<p>Each pvData datum (i.e. an instance of PVField) has an introspection
description (i.e. an instance of a Field). A PVField is encoded as raw values
only. The Field provides metadata, which describes the data type of its
associated PVField. Since many different PVField instances share the same
introspection description, it SHOULD be cached to avoid repeatedly sending it
over the wire. Thus, Field encoding starts with a byte whose value must be one
of the following: NULL, ID only or ID with actual Field serialization. The ID
MUST be encoded as short, and is a key used to cache Field descriptions. This
cache is called the "introspection registry". IDs MUST be valid only within one
connection. Moreover, they MUST be defined only by the sender. The receiver
MUST only keep track of IDs to be able to do deserialization. Since
communication is full-duplex this implies there MUST be two introspection
registries per connection. Sender MAY override previously assigned ID by simply
assiging the ID to a new Field. Introspection registry size MUST be negotiated
when connection is established. </p>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Field Encoding.</caption>
  <tbody>
    <tr>
      <th>Field Encoding</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>0xFF</td>
      <td style="font-weight:bold">NULL_TYPE_CODE</td>
      <td>No introspection data.</td>
    </tr>
    <tr>
      <td>0xFE + ID</td>
      <td style="font-weight:bold">ONLY_ID_TYPE_CODE</td>
      <td>Serialization contains only an ID (that was assigned by one of the
        previous FULL_WITH_ID descriptions).</td>
    </tr>
    <tr>
      <td>0xFD + ID + FieldDesc</td>
      <td style="font-weight:bold">FULL_WITH_ID_TYPE_CODE</td>
      <td>Serialization contains an ID (that can be used later, if cached) and
        full interface description.</td>
    </tr>
  </tbody>
</table>

<p>An actual Field introspection description (FieldDesc) MUST be encoded as a
byte that consists of 2 nibbles (4-bits). The upper nibble (MSBs) defines Field
type (i.e. Type), the low nibble (LSBs) defines the data type (i.e. ScalarType)
for scalar and scalarArray types. That byte MUST be then followed by the Field
instance name encoded as a string. Structure and structureArray types REQUIRE
more description. A structure REQUIRES an array of Fields (size followed by one
or more Field as described above). StructureArray is similar, in addition it
REQUIRES the name of the structure. </p>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">FieldDesc Encoding.</caption>
  <tbody>
    <tr>
      <th>FieldDesc Encoding</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>0x00 | ScalarType (0b0000xxxx) + name</td>
      <td style="font-weight:bold">scalar</td>
      <td>Scalar.</td>
    </tr>
    <tr>
      <td>0x10 | ScalarType (0b0000xxxx) + name</td>
      <td style="font-weight:bold">scalarArray</td>
      <td>Array of scalars.</td>
    </tr>
    <tr>
      <td>0x20 (0b00100000) + name + Field[]</td>
      <td style="font-weight:bold">structure</td>
      <td>Structure.</td>
    </tr>
    <tr>
      <td>0x30 (0b00110000) + name + (structure name + Field[])</td>
      <td style="font-weight:bold">structureArray</td>
      <td>Array of structures.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">ScalarType Nibble Encoding.</caption>
  <tbody>
    <tr>
      <th>Encoding</th>
      <th>ScalarType</th>
    </tr>
    <tr>
      <td>0 (0b0000)</td>
      <td style="text-align:left;font-weight:bold">boolean</td>
    </tr>
    <tr>
      <td>1 (0b0001)</td>
      <td style="text-align:left;font-weight:bold">byte</td>
    </tr>
    <tr>
      <td>2 (0b0010)</td>
      <td style="text-align:left;font-weight:bold">short</td>
    </tr>
    <tr>
      <td>3 (0b0011)</td>
      <td style="text-align:left;font-weight:bold">int</td>
    </tr>
    <tr>
      <td>4 (0b0100)</td>
      <td style="text-align:left;font-weight:bold">long</td>
    </tr>
    <tr>
      <td>5 (0b0101)</td>
      <td style="text-align:left;font-weight:bold">float</td>
    </tr>
    <tr>
      <td>6 (0b0110)</td>
      <td style="text-align:left;font-weight:bold">double</td>
    </tr>
    <tr>
      <td>7 (0b0111)</td>
      <td style="text-align:left;font-weight:bold">string</td>
    </tr>
  </tbody>
</table>

<h4 id="dataEncoding:example">Example</h4>

<p>Given the following structure, as may be expressed by a pvData Structure:
</p>
<pre>structure test1
    structure timeStamp
        long secondsPastEpoch
        int nanoSeconds
    structure[] value
        structure org.epics.ioc.test.testStructure
            double value
            structure location
                double x
                double y
    string factoryRPC
    structure arguments
        int size
    structure element
        double value
        structure alarm
            int severity
            string message
        structure timeStamp
            long secondsPastEpoch
            int nanoSeconds</pre>

<p>The introspection description of the above structure is be encoded by
pvAccess as the following: </p>
<pre>FD 00 01 20  05 74 65 73  74 31 05 FD  00 02 20 09  .... .tes t1.. .... 
74 69 6D 65  53 74 61 6D  70 02 04 10  73 65 63 6F  time Stam p... seco 
6E 64 73 50  61 73 74 45  70 6F 63 68  03 0B 6E 61  ndsP astE poch ..na 
6E 6F 53 65  63 6F 6E 64  73 FD 00 03  30 05 76 61  noSe cond s... 0.va 
6C 75 65 20  6F 72 67 2E  65 70 69 63  73 2E 69 6F  lue  org. epic s.io 
63 2E 74 65  73 74 2E 74  65 73 74 53  74 72 75 63  c.te st.t estS truc 
74 75 72 65  02 06 05 76  61 6C 75 65  FD 00 04 20  ture ...v alue ...  
08 6C 6F 63  61 74 69 6F  6E 02 06 01  78 06 01 79  .loc atio n... x..y 
07 0A 66 61  63 74 6F 72  79 52 50 43  FD 00 05 20  ..fa ctor yRPC ...  
09 61 72 67  75 6D 65 6E  74 73 01 03  04 73 69 7A  .arg umen ts.. .siz 
65 FD 00 06  20 07 65 6C  65 6D 65 6E  74 03 06 05  e...  .el emen t... 
76 61 6C 75  65 FD 00 07  20 05 61 6C  61 72 6D 02  valu e...  .al arm. 
03 08 73 65  76 65 72 69  74 79 07 07  6D 65 73 73  ..se veri ty.. mess 
61 67 65 FE  00 02                                  age. ..</pre>

<h3 id="dataEncoding:data">Data</h3>

<p>Data (i.e. PVField) MUST encode raw values. </p>

<p>Each structure can (depending on message definition) have a BitSet instance
defining what subset of that structure's fields have been serialized. This
allows partial serialization of structures. That is, sending only fields that
have changed rather then the entire structure. Each node of a structure
corresponds to one bit; if a bit is set then its corresponding field has been
serialized, otherwise not. BitSet does not apply to array elements. </p>

<h4 id="data:example1">Example #1</h4>
<pre>structure 
    byte[] value [1,2,3]
    structure timeStamp
        long secondsPastEpoch 0x1122334455667788
        int nanoSeconds 0xAABBCCDD
        int userTag 0xEEEEEEEE
    structure alarm
        int severity 0x11111111
        int status 0x22222222
        string message Allo, Allo!</pre>

<p>is serialzied as (big-endian byte-order): </p>
<pre>Hexdump [Serialized structure] size = 40
03 01 02 03  11 22 33 44  55 66 77 88  AA BB CC DD  .... ."3D Ufw. .... 
EE EE EE EE  11 11 11 11  22 22 22 22  0B 41 6C 6C  .... .... """" .All 
6F 2C 20 41  6C 6C 6F 21                            o, A llo! </pre>

<h4 id="data:example2">Example #2</h4>

<p>This example shows how bits of a BitSet are assigned to the fields of a
structure: </p>
<pre>bit#    field
0    structure 
1        structure timeStamp
2            long secondsPastEpoch 
3            int nanoSeconds 
4        structure[] value 
            structure org.epics.ioc.test.testStructure
                double value 
                structure location
                    double x
                    double y
            structure org.epics.ioc.test.testStructure
                double value 
                structure location
                    double x
                    double y 
5        string factoryRPC
6        structure arguments
7            int size
8        structure element
9            double value
10            structure alarm
11                int severity
12                string message 
13            structure timeStamp
14                long secondsPastEpoch
15                int nanoSeconds</pre>

<p>The structure above requires 16 bits.<br />
If bit corresponding to a structure node is set then all the fields of that
node MUST be de-/serialized. </p>

<h2 id="connectionManagement">Connection Management</h2>

<p>Each TCP connection has associated QoS parameters. Regardless of how many
channels are handled by either client or server, each client and server pair
MUST be connected with exactly one TCP connection for each QoS parameter value.
</p>

<p>When establishing a TCP connection, a simple handshake MUST be performed.
The client opens a TCP connection to the server and waits until the Connection
Validation message is received. The server MUST initially send a Set byte-order
control message to notify the client about byte-order to be used for this TCP
connection. After that the server MUST send the Connection Validation message.
If client correctly decodes messages it responds with a Connection Validation
response message. After that, client may start sending requests. The client
SHOULD keep the connection established until the last active channel gets
destroyed. However, to optimize resource reallocation it MAY delay connection
destruction. </p>

<p>Both parties MUST constantly monitor connection is valid and not simply
relay on TCP mechanisms. The only way to ensure this is by sending data. If
there is no send operation called within a predetermined period of time, an
echo message MUST be sent. In case of connection failure, TCP will report
connection loss on send. If there is no response in a predetermined period of
time, the connection SHOULD be marked as unresponsive. Echo message MUST be
periodically sent until response is received or connection is reported to be
lost. If echo response is received and transport is marked as unresponsive,
transport SHOUD be reported to be responsive. </p>

<div class="image" style="text-align:center">
<img src="image/pvAccessSpec_ConnectionStates.png"
alt="Connection State Diagram" width="66%" /> 

<div style="font-weight:bold">
Connection State Diagram.</div>
</div>

<p>When connection is closed all related resources MUST be freed. On server
side all channels including their requests MUST be destroyed. On client side
all channels and their requests MUST be put to disconnected state and searching
for channels initiated. All related ID-s MUST be freed too, i.e.
serverChannelID, clientChannelID, and requestID-s. They MAY be recycled - used
for other channels/requests in the future. <br />
When disconnected client channels are found on the network and connection is
re-established, channels are put to back to connected state and all their
requests re-initialized; in addition, monitors are re-started. </p>

<h2 id="channelLifecycle">Channel Life-cycle</h2>

<div class="image" style="text-align:center">
<img src="image/pvAccessSpec_ChannelStates.png" alt="Channel State Diagram"
width="66%" /> 

<div style="font-weight:bold">
Channel State Diagram.</div>
</div>

<p>When a channel is instantiated by a client application, its state MUST be
set to NEVER_CONNECTED state. This indicates that the channel is currently
being connected for the first time. Connection proccess within the client MUST
repetedly attempt to find a server hosting the channel by
broadcasting/multicasting channel search requests. When a server response is
received, the client MUST connect to the server responding to the search
request using protocol and address data from the search request response. If
connection is already established by the client, it MUST be reused. Client API
MAY also allow user-specified server address; in this case, searching process
is by-passed and specified server address data directly used. </p>

<p>When connection is established and verified, the channel create request
message MUST be sent the server. When the client receives a channel create
response message with success status, it MUST set the channel to CONNECTED
state. </p>

<p>Channel MUST be in CONNECTED state to be able to accept channel related
requests. </p>

<p>When the connection is lost, the channel state MUST be set to DISCONNECTED.
In this state client MUST start the connection process as descibed above. On
re-connect, channel state MUST be set back to CONNECTED. </p>

<p>A channel MAY be destroyed any time (in any state) and then its state MUST
be set to DESTROYED. Once the channel is destroyed, it MUST NOT be used
anymore. </p>

<h2 id="channelRequestLifecycle">Channel Request Life-cycle</h2>

<div class="image" style="text-align:center">
<img src="image/pvAccessSpec_RequestStates.png"
alt="Channel Request State Diagram" width="66%" /> 

<div style="font-weight:bold">
Channel Request State Diagram.</div>
</div>

<p>Channel requests (get, put, get-put, RPC, process) have a state. When
instantiated, they MUST are in INIT state. A specific per request
initialization message MUST be sent to the server. The request MUST NOT be used
until successful initialization response is received from the server and put to
READY state. If initialization fails, client MUST be notified about failure and
the request put to DESTROYED state. </p>

<p>Actual actions, e.g. get, MAY be invoked only when a request is in READY
state. When one action is in progress, the request is put to
REQUEST_IN_PROGRESS state and set back to READY state when ended. This implies
that actions MUST NOT be run in parallel. </p>

<p>When connection is lost, a request MUST be put to DISCONNECTED state and
automatically re-initialized when connection is re-established (as the request
where newly instantiated). </p>

<p>A request MAY be destroyed any time (in any state) and then its state MUST
be set to DESTROYED. Once the request is destroyed, it MUST NOT be used
anymore. </p>

<h2 id="flowControl">Flow Control</h2>

<p>Usually flow control algorithms wait for congestion to occur before they are
triggered. They are causal. However, due to the isolated nature of TCP
connection - there are always only two parties involved - it is possible to
predict congestions using the following algorithm: </p>
<ul>
  <li>both parties exchange their receive socket and local buffer sizes</li>
  <li>periodically, i.e. every N bytes, they send a control message marking
    total bytes sent to the other party</li>
  <li>when the other party receives the control message it responds back with
    complementary control message indicating the received marker value. This
    acknowledges the reception of total bytes sent</li>
  <li>the difference between total bytes sent and last acknowledged marker
    received tells how much other party receive buffers are full. This number
    should never exceed the total sum of receive buffers.</li>
</ul>

<p>Flow control is needed only to optimize subscription messages back to the
client (i.e. monitors), for other large messages TCP flow control is
sufficient. <br />
A pvAccess implementation SHOULD implement flow control such that each endpoint
should try to send as much monitoring data as it can subject to an upper limit
calculated with respect to the amount of other party's free receive buffer
size. Were this limit to be reached, monitors would start pilling up in the
monitors' circular buffer queues. </p>

<h3 id="flowControlExample">Flow Control Example</h3>

<p>The intention of flow control is to avoid having the following behavior
(pure TCP flow control): </p>
<ul>
  <li>Let's assume the client's Rx buffers are full</li>
  <li>The server is sending monitors until TCP detects client's Rx buffer is
    full</li>
  <li>After some time the client's Rx buffer is immediately emptied (since we
    do bulk reads from the socket - not message by message (because OS calls
    are expensive))</li>
  <li>Server starts sending monitors until all the buffers are full (sever will
    fill all the buffers before client actually processed received
  monitors!)</li>
</ul>

<p>Such as situation as described above would result in monitors as below
(identified by their sequential number): </p>
<pre>0 1 2 3 4 (buffers full) 7 8 9 10 11 12 (buffers full) 22 23 24 25 26 27 28 (buffers full)</pre>

<p>Flow control can make this better: </p>
<pre>0 1 2 3 4 (buffers full) 7 8 (buffers full, but for a less time since server would send only as much as the client can handle) 10 11 (...) 14 15 (...) 18 19</pre>

<p>The result is more fluid and up-to-date arrival of monitors (to overcome
problem of having combination of slow processing and large buffers). </p>

<p>Requiring a flow control (in addition to already existing monitor queues)
adds complexity to the protocol implementation. It needs to be decided and
evaluated if flow control SHOULD be implemented. </p>

<h2 id="channelDiscovery">Channel Discovery</h2>

<p>pvAccess uses broadcast/multicast channel discovery mechanism via UDP;
search messages are usually sent to a broadcast addresses and servers hosting
searched channels respond with a message containing their server address and
port.<br />
In addition pvAccess transparently supports multicast, if an address is a
multicast address the implementation SHOULD transparently handle it. </p>

<p>To be specified: Proper UDP congestion control SHOULD be implemented to
prevent flooding the network with UDP search messages. Currently a simple and
robust algorithm is used in the reference implementation. The algorithm needs
to be specified (or some more clever algorithm invented). </p>

<h2 id="protocolMessages">Protocol Messages</h2>

<p>The pvAccess protocol uses two protocol message types: </p>
<ul>
  <li>control messages (flow control, no payload)</li>
  <li>application messages (requests and their responses).</li>
</ul>

<p>Each message consists of a message header and, optionally a message payload
that immediately follows the header. Message MUST BE aligned to 64-bits. </p>

<h3 id="protocolMessages:messageHeader">Message header</h3>

<p>Each protocol message has a fixed 8-byte header that MUST be encoded as if
it were expressed by the following structure: </p>
<pre>struct pvAccessHeader {
    byte magic;
    byte version;
    byte flags;
    byte messageType;
    int payloadSize;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">pvAccess Header Members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">magic</td>
      <td>pvAccess protocol magic code, 0xCA.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">version</td>
      <td>Protocol version.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">flags</td>
      <td>Message flags.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">messageType</td>
      <td>Message type (i.e. create, get, put, process, etc.).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">payloadSize</td>
      <td>Message payload size (non-aligned, in bytes).</td>
    </tr>
  </tbody>
</table>

<p>Protocol MUST be backward compatible. Current version is 0. </p>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">pvAccess Header Flags Description.</caption>
  <tbody>
    <tr>
      <th>bit</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">0</td>
      <td>Application/Control [0/1] message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">1,2,3</td>
      <td>Unused</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">4</td>
      <td>First message (of set of segmented messages).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">5</td>
      <td>Last message (of set of segmented messages).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">6</td>
      <td>Unused.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">7</td>
      <td>Little/Big [0/1] endian byte order.</td>
    </tr>
  </tbody>
</table>

<p>NOTE: If bits 4 and 5 are both set, this indicates this message is between
the first and last message of a set of segmented messages. This implies that
bit 4 MUST be set for all but the last message, and bit 5 MUST be set for all
but the first message. <br />
If neither is set then this message MUST not be a part of a segmented set. <br
/>
Between two segmented message of the same set there MUST NOT be any other
application message then the segmented message of the same set. Control
messages are allowed to be in-between. </p>

<h2 id="protocolMessages:applicationMessages">Application Messages</h2>

<p>This section describes all the application messages (0-th bit of
<i>pvAccessHeader.flags</i> is not set) for different
<i>pvAccessHeader.messageType</i> values. </p>

<p>In order to understand specific application messages it is strongly
recommended to be familiar with the <a
href="http://epics-pvdata.sourceforge.net/docbuild/pvAccessJava/tip/documentation/pvAccessJava.html">pvAccess
client interface</a>.</p>

<p>All application message MUST be send over the data transmission transport -
TCP/IP in reference implementation - unless explicitly specified. A response
message MUST be sent over the same transport the request was received.</p>

<h3 id="protocolMessages:applicationMessages:beacon">Beacon (0x00)</h3>

<p>Beacons MUST be broadcasted/multicasted over UDP. Beacons SHOULD be used to
announce new servers and server restarts. </p>
<pre>struct beaconMessage {
    short beaconSequenceId;
    long startupTimeSeconds;
    int startupTimeNanos;
    byte[16] serverAddressIPv6;
    short serverPort;
    string protocol;
    FieldDesc serverStatusIF;
    [if serverStatusIF != NULL_TYPE_CODE] PVField serverStatus;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Beacon Message Members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">beaconSequenceId</td>
      <td>Beacon sequence ID (counter w/ rollover). Can be used to detect UDP
        routing problems.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">startupTimeSeconds</td>
      <td>Server startup time (POSIX time).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">startupTimeNanos</td>
      <td>Server startup time (nanoseconds part).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverAddressIPv6</td>
      <td>Server IPv6 address (or IPv6 encoded IPv4 address).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverPort</td>
      <td>Server port (where server is listening).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">protocol</td>
      <td>Protocol name, e.g. "tcp" for standard pvAccess TCP/IP
      communication.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverStatusIF</td>
      <td>Optional server status Field description, NULL_TYPE_CODE is none.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverStatus</td>
      <td>Optional server data.</td>
    </tr>
  </tbody>
</table>

<p>A beacon received from an as yet unknown serverAdddressIPv6:serverPort means
new server has come online. A beacon with the same
serverAdddressIPv6:serverPort address as one already received but different
startupTime{Seconds,Nanos} means that a server was restarted. In both cases
client SHOULD boost searching of not yet found channels. Client MAY disconnect
old connection or wait until connection loss is detected (on failed Echo
message send). </p>

<p>Each server implementation SHOULD emit its own beacons, e.g. if a server is
supporting data transmission over TCP/IP and UDP/IP there SHOULD both emit
beacons. If the implementations are tightly coupled, i.e. they have the same
lifecycle and share the same channels, then only one server MIGHT emit beacons.
</p>

<p>NOTE: Servers SHOULD synchronize their internal clocks using NTP or some
other suitable time source before sending their first beacon.<br />
NOTE: Due to the fact that UDP does not guarantee delivery, a server MUST send
several beacons to notify that it is alive (e.g. 15 beacons with 1Hz period).
After longer period it MAY stop sending them, however it is recommended that is
SHOULD do it with a low rate (one beacon per every couple of minutes) to report
serverStatus.<br />
NOTE: Beacons SHOULD not used to report connection-valid status. </p>

<h3 id="protocolMessages:applicationMessages:connectionValidation">Connection
validation (0x01)</h3>

<p>A "connection validation" message MUST be first application message sent
from the server to a client when a TCP/IP connection is established. The
message indicates that the server is ready to receive requests; the client MUST
NOT send any messages on the connection until it has received a connection
validation message from the server. </p>

<p>The purpose of the connection validation message is two-fold: </p>
<ul>
  <li>It informs the client of the connection and protocol details</li>
  <li>It prevents the client from writing a request message to its local
    transport buffers until after the server has acknowledged that it can
    actually process the request. This avoids a race condition caused by the
    server's TCP/IP stack accepting connections in its backlog while the server
    is in the process of shutting down. If the client were to send a request in
    this situation, the request would be lost but the client could not safely
    reissue the request because that might violate at-most-once semantics.</li>
</ul>

<p>The connection validation message guarantees that a server is not in the
middle of shutting down when the server's TCP/IP stack accepts an incoming
connection and so avoids the race condition. </p>
<pre>struct connectionValidationRequest {
    int serverReceiveBufferSize;
    int serverReceiveSocketBufferSize;
    short serverIntrospectionRegistryMaxSize;
};

struct connectionValidationResponse {
    int clientReceiveBufferSize;
    int clientReceiveSocketBufferSize;
    short clientIntrospectionRegistryMaxSize;
    short connectionQos;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Connection Validation Request Message
  Members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td
      style="text-align:right;font-family:monospace">serverReceiveBufferSize</td>
      <td>Server receive buffer size in bytes.</td>
    </tr>
    <tr>
      <td
        style="text-align:right;font-family:monospace">serverReceiveSocketBufferSize</td>
      <td>Server socket buffer size in bytes.</td>
    </tr>
    <tr>
      <td
        style="text-align:right;font-family:monospace">serverIntrospectionRegistryMaxSize</td>
      <td>Maximum number of introspection registry entries server is able to
        handle.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Connection Validation Response Message
  Members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td
      style="text-align:right;font-family:monospace">clientReceiveBufferSize</td>
      <td>Client receive buffer size in bytes.</td>
    </tr>
    <tr>
      <td
        style="text-align:right;font-family:monospace">clientReceiveSocketBufferSize</td>
      <td>Client socket buffer size in bytes.</td>
    </tr>
    <tr>
      <td
        style="text-align:right;font-family:monospace">clientIntrospectionRegistryMaxSize</td>
      <td>Maximum number of introspection registry entries client is able to
        handle.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">connectionQoS</td>
      <td>Connection QoS parameters.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Connection QoS Parameters
  Description.</caption>
  <tbody>
    <tr>
      <th>bit</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">0-6</td>
      <td>Priority level [0-100].</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">7</td>
      <td>Unused.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">8</td>
      <td>Low-latency priority.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">9</td>
      <td>Throughput priority.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">10</td>
      <td>Enable compression.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">11-15</td>
      <td>Unused.</td>
    </tr>
  </tbody>
</table>

<p>Each QoS parameter value REQUIRES a separate TCP/IP connection. Low-latency
priority bit signals transport implementation to try to respond with low
latency. Throughput priority bit signals transport implementation to try to
maximize throughput. How this is achieved depends on specific implementation.
Compression bit enables compression for the connection (TBD: fast and streaming
mode algorithm to be used). </p>

<h3 id="protocolMessages:applicationMessages:echo">Echo (0x02)</h3>

<p>An Echo diagnostic message is usually sent to check if TCP/IP connection is
still valid. It can also be broadcasted over UDP/IP to get list of all servers
in the subnet (note that UDP does not guarantee delivery). </p>
<pre>struct echoRequest {
    byte[] somePayload;
};

struct echoResponse {
    byte[] samePayloadAsInRequest;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Echo request message members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">somePayload</td>
      <td>Arbitrary payload content, can be empty.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Echo response message members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td
      style="text-align:right;font-family:monospace">samePayloadAsInRequest</td>
      <td>Same paylaod as in request message.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:searchRequest">Search request
(0x03)</h3>

<p>A channel "search request" message SHOULD be sent over UDP/IP, however UDP
congestion control SHOULD be implemented in this case. Server MUST accept this
message also over TCP/IP. </p>
<pre>        
struct searchRequest {
    int searchSequenceID;
    byte replyRequired;
    struct {
        int searchInstanceID;
        string channelName;
    } channels[];
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Search request message members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">searchSequenceID</td>
      <td>Search sequence ID (counter w/ rollover), can be used by congestion
        control algorithms.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">replyRequired</td>
      <td>0x01 to force server to respond even if it does not host channel(s),
        0x00 otherwise.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">searchInstanceID</td>
      <td>ID to be used to associate response with the following channel
      name.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">channelName</td>
      <td>Non-empty channel name, maximum length of 500 characters.</td>
    </tr>
  </tbody>
</table>

<p>The response to a search request MUST be sent as messageType 0x04, see
below. </p>

<h3 id="protocolMessages:applicationMessages:searchResponse">Search response
(0x04)</h3>

<p>A "search response" message MUST be sent as the response to a search request
(0x03) message. </p>
<pre>struct searchResponse {
    int searchSequenceID;
    boolean found;
    byte[16] serverAddressIPv6;
    short serverPort;
    string protocol;
    int[] searchInstanceIDs;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Search response message members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">searchSequenceID</td>
      <td>Search sequence ID, same as specified in search request.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">found</td>
      <td>Flag indicating whether response contains IDs of found or not found
        channels.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverAddressIPv6</td>
      <td>Server IPv6 address (or IPv6 encoded IPv4 address).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverPort</td>
      <td>Server port (where server is listening).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">protocol</td>
      <td>Protocol name, e.g. "tcp" for standard pvAccess TCP/IP
      communication.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">searchInstanceIDs</td>
      <td>IDs, associated with names in the request, relevant to this
      response.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:createChannel">Create channel
(0x07)</h3>

<p>A channel provides a communication path beween a client and a server hosted
process variable. A "create channel" message is sent to a server to create a
channel. Each channel instance MUST be bound only to one connection. </p>
<pre>struct createChannelRequest {
    struct {
        int clientChannelID;
        string channelName;
    } channels[];
};

struct createChannelResponse {
    int clientChannelID;
    int serverChannelID;
    Status status;
    [if status.type == OK | WARNING] short accessRights;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Create channel request message
  members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">clientChannelID</td>
      <td>Client generated channel ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">channelName</td>
      <td>Name of the channel to be created, non-empty and maximum length of
        500 characters.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Create channel response (per channel)
  message members.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">clientChannelID</td>
      <td>Client generated channel ID, same as in request</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">accessRights</td>
      <td>Access rights (TBD).</td>
    </tr>
  </tbody>
</table>

<p>NOTE: A server MUST store the clientChannelID and respond back with its
value in a destroyChannelMessage when channel destroy request is requested, see
below. A client uses the serverChannelID value for all subsequent requests on
the channel. Code MUST NOT make any assumptions/checks about how given IDs are
generated. IDs MUST be unique within a connection and MAY be recycled once
channel is disconnected.</p>

<h3 id="protocolMessages:applicationMessages:destroyChannel">Destroy channel
(0x08)</h3>

<p>A "destroy channel" message is sent to a server to destroy a channel that
was previously created with create channel message. </p>
<pre>struct destroyChannelRequest {
    struct {
        int clientChannelID;
        int serverChannelID;
    } channels[];
};

struct destroyChannelResponse {
    struct {
        int clientChannelID;
        int serverChannelID;
        Status status;
    } channels[];
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Destroy channel request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">clientChannelID</td>
      <td>Client generated channel ID, same as in create request.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create response.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Destroy channel response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">clientChannelID</td>
      <td>Client generated channel ID, same as in create request.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>

<p>Server MAY break response message to several messages. If (clientChannelID,
serverChannelID) pair does not match, server MUST respond with an error status.
</p>

<p>NOTE: A server MUST send this message to a client to notify the client about
server-side initiated channel destruction. Subsequently, a client MUST mark
channel as disconnected and start sending search request messages for the
channel.<br />
</p>

<h3 id="protocolMessages:applicationMessages:channelGet">Channel get (0x0A)</h3>

<p>A "channel get" set of messages are used to retrieve (get) data from the
channel. </p>
<pre>struct channelGetRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08 for INIT;
    FieldDesc pvRequestIF;
    PVField pvRequest;
};

struct channelGetResponseInit {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] FieldDesc pvStructureIF;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel get init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>pvRequest Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel get init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvStructureIF</td>
      <td>pvStructure (data container) Field description.</td>
    </tr>
  </tbody>
</table>

<p>After get request is successfully initialized, client can issue actual get
request(s). </p>
<pre>struct channelGetRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x40 for GET; additional 0x10 mask for DESTROY;
};

struct channelGetResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] BitSet changedBitSet;
    [if status.type == OK | WARNING] PVField pvStructureData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel get request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x40 for GET, additional 0x10 mask for DESTROY.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel get response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">changedBitSet</td>
      <td>Changed BitSet for pvStructureData.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvStructureData</td>
      <td>Data structure.</td>
    </tr>
  </tbody>
</table>

<p>NOTE: if DESTROY mask is applied, server MUST destroy request after get
response and client MUST do the same after it receives the response. </p>

<h3 id="protocolMessages:applicationMessages:channelPut">Channel put (0x0B)</h3>

<p>A "channel put" set of messages are used to set (put) data to the channel.
</p>
<pre>struct channelPutRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08;
    FieldDesc pvRequestIF;
    PVField pvRequest;
};

struct channelPutResponseInit {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] FieldDesc pvPutStructureIF;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel put init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>pvRequest Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel put init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvPutStructureIF</td>
      <td>pvPutStructure (data container) Field description.</td>
    </tr>
  </tbody>
</table>

<p>After put request is successfully initialized, client can issue actual put
request(s). </p>
<pre>struct channelPutRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x00 for PUT; 0x10 mask for DESTROY;
    BitSet toPutBitSet;
    PVField pvPutStructureData;
};

struct channelPutResponse {
    int requestID;
    byte subcommand;
    Status status;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel put request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x00 for PUT, additional 0x10 mask for DESTROY.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">toPutBitSet</td>
      <td>To-put BitSet for pvPutStructureData.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvPutStructureData</td>
      <td>Data to put structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel put response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>

<p>A "get-put" request retrieves remote put structure. This MAY be used by user
applications to show data that were set last time. </p>
<pre>struct channelGetPutRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x40;
};

struct channelGetPutResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] PVField pvPutStructureData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel get put request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x40.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel get put response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvPutStructureData</td>
      <td>Remote put data structure.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:channelPutGet">Channel put-get
(0x0C)</h3>

<p>A "channel put-get" set of messages are used to set (put) data to the
channel and then immediately retrieve data from the channel. Channel is usually
processed between put and get. </p>
<pre>struct channelPutGetRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08;
    FieldDesc pvRequestIF;
    PVField pvRequest;
};

struct channelPutGetResponseInit {
    int requestID;
    byte subcommand; 
    Status status;
    [if status.type == OK | WARNING] FieldDesc pvPutStructureIF;
    [if status.type == OK | WARNING] FieldDesc pvGetStructureIF;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel put-get init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>pvRequest Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel put-get init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvPutStructureIF</td>
      <td>pvPutStructure (data container) Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvGetStructureIF</td>
      <td>pvGetStructure (data container) Field description.</td>
    </tr>
  </tbody>
</table>

<p>After put-get request is successfully initialized, client can issue actual
put-get request(s). </p>
<pre>struct channelPutGetRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x00 for PUT_GET; 0x10 mask for DESTROY;
    BitSet toPutBitSet;
    PVField pvPutStructureData;
};

struct channelPutGetResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] PVField pvGetStructureData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel put-get request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x00 for PUT_GET, additional 0x01 mask for DESTROY.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">toPutBitSet</td>
      <td>To-put BitSet for pvPutStructureData.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvPutStructureData</td>
      <td>Data to put structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel put-get response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvGetStructureData</td>
      <td>Get data structure.</td>
    </tr>
  </tbody>
</table>

<p>A "get-put" request retrieves remote put structure. This MAY be used by user
applications to show data that were set last time. </p>
<pre>struct channelGetPutRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x80;
};

struct channelGetPutResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] PVField pvPutStructureData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel get put request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x80.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel get put response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvPutStructureData</td>
      <td>Remote put data structure.</td>
    </tr>
  </tbody>
</table>

<p>A "get-get" request retrieves remote get structure. This MAY be used by user
applications to show data that were retrieved last time. </p>
<pre>struct channelGetGetRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x40;
};

struct channelGetGetResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] PVField pvGetStructureData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel get get request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x40.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel get get response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvGetStructureData</td>
      <td>Remote get data structure.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:channelMonitor">Channel monitor
(0x0D)</h3>

<p>A "channel monitor" set of messages are used to monitor data of the channel
using subscribe mechanism. </p>
<pre>struct channelMonitorRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08;
    FieldDesc pvRequestIF;
    PVField pvRequest;
};

struct channelMonitorResponseInit {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] FieldDesc pvStructureIF;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel monitor init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>pvRequest Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel monitor init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvStructureIF</td>
      <td>pvStructure (data container) Field description.</td>
    </tr>
  </tbody>
</table>

<p>pvRequest structure SHOULD be used to specify monitor queue size and
algorithm (all implementation specific). </p>

<p>After monitor request is successfully initialized, client can issue actual
monitor request(s). </p>

<p>The following messages MUST be used to start (resume), stop (suspend)
monitoring and to destroy monitor request (subscription): </p>
<pre>struct channelStartMonitorRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x44;
};</pre>
<pre>struct channelStopMonitorRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x04;
};</pre>
<pre>struct channelDestroyMonitorRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x10;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel monitor requests.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x44 for START, 0x04 for STOP, 0x10 for DESTROY.</td>
    </tr>
  </tbody>
</table>

<p>There is response for requests above. </p>
<pre>struct channelMonitorResponse {
    int requestID;
    byte subcommand = 0x00;
    BitSet changedBitSet;
    PVField pvStructureData;
    BitSet overrunBitSet;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel monitor response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in monitor init request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x00.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">changedBitSet</td>
      <td>Changed BitSet for pvStructureData.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvStructureData</td>
      <td>Data structure.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">overrunBitSet</td>
      <td>BitSet indicating overrun fields.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:channelArray">Channel array
(0x0E)</h3>

<p>A "channel array" set of messages are used to handle remote arrays. Requests
allows you to: retrieve (get) and set (put) data from/to the array, and
changing its length (number of valid elements in the array) and capacity. </p>
<pre>struct channelArrayRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08;
    FieldDesc pvRequestIF;
    PVField pvRequest;
};

struct channelArrayResponseInit {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] FieldDesc pvArrayIF;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel array init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>pvRequest Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel array init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvArrayIF</td>
      <td>pvArray (data container) Field description.</td>
    </tr>
  </tbody>
</table>

<p>After array request is successfully initialized, client can issue actual
array request(s). </p>
<pre>struct channelGetArrayRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x40 mask for GET; 0x10 mask for DESTROY;
    int offset;
    int count;
};

struct channelGetArrayResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] PVField pvArrayData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel array get request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x40 for GET, additional 0x10 mask for DESTROY.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">offset</td>
      <td>Offset from the beginning of the array (if positive) or end of the
        array (if negative).</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">count</td>
      <td>Number of elements requested, -1 means form offset to the end of the
        array.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel array get response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvArrayData</td>
      <td>Data array.</td>
    </tr>
  </tbody>
</table>
<pre>struct channelPutArrayRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x00 mask for PUT; 0x10 mask for DESTROY;
    int offset;
    PVField pvArrayData;
};

struct channelPutArrayResponse {
    int requestID;
    byte subcommand;
    Status status;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel array put request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x00 for PUT, additional 0x10 mask for DESTROY.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">offset</td>
      <td>Offset from the beginning of the array (if positive) or end of the
        array (if negative) where to put given subarray.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvArrayData</td>
      <td>Subarray to be put.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel array put response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>
<pre>struct channelSetLengthRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x80 mask for SET_LENGTH; 0x10 mask for DESTROY;
    int length;
    int capacity;
};

struct channelSetLengthResponse {
    int requestID;
    byte subcommand;
    Status status;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel array set length request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x40 for GET, additional 0x10 mask for DESTROY.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">length</td>
      <td>New length, -1 to keep old value.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">capacity</td>
      <td>New capacity, -1 to keep old value.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel array set length response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:destroyRequest">Destroy request
(0xF)</h3>

<p>A "destroy request" messages is used destroy any request instance, i.e. an
instance with requestID. </p>
<pre>// destroys any request with given requestID
struct destroyRequest {
    int serverChannelID;
    int requestID;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Destroy request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request init message.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:channelProcess">Channel process
(0x10)</h3>

<p>A "channel process" set of messages are used to trigger channel to process.
</p>
<pre>struct channelProcessRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08;
    FieldDesc pvRequestIF;
    [if serverStatusIF != NULL_TYPE_CODE] PVField pvRequest;
};

struct channelProcessResponseInit {
    int requestID;
    byte subcommand;
    Status status;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel process init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>Optional pvRequest Field description, NULL_TYPE_CODE is none.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>Optional pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel process init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>

<p>After process request is successfully initialized, client can issue actual
process request(s). </p>
<pre>struct channelProcessRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x00 mask for PROCESS; 0x10 mask for DESTROY;
};

struct channelProcessResponse {
    int requestID;
    byte subcommand;
    Status status;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel proces request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x00 for PROCESS, additional 0x10 mask for DESTROY.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel process response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:channelGetField">Get channel type
introspection data (0x11)</h3>

<p>A "get channel type introspection data" messages is used to retrieve channel
type introspection data, i.e. description of all channel fields and their
types. </p>
<pre>struct channelGetFieldRequest {
    int serverChannelID;
    int requestID;
    string subFieldName;  // entire record if empty
};

struct channelGetFieldResponse {
    int requestID;
    Status status;
    [if status.type == OK | WARNING] FieldDesc subFieldIF;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Get channel introspection data
  request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subFieldName</td>
      <td>Name of the subfield to get or entire record if empty.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Get channel introspection data
  response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subFieldIF</td>
      <td>Requested field introspection data.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:message">Message (0x12)</h3>

<p>A "message" message is used by a server to provide a client human readable
messages regarding a specific request. This message MUST NOT be used to report
request completion status. </p>
<pre>struct message {
    int requestID;
    byte messageType; // info = 0, warning = 1, error = 2, fatalError = 3
    string message;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Message response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">messageType</td>
      <td>Message type enum.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">message</td>
      <td>Message.</td>
    </tr>
  </tbody>
</table>

<h3 id="protocolMessages:applicationMessages:channelRPC">Channel RPC (0x14)</h3>

<p>A "channel RPC" set of messages are used to provide remote procedure call
(RPC) support over pvAccess. </p>
<pre>struct channelRPCRequestInit {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x08;
    FieldDesc pvRequestIF;
    PVField pvRequest;
};

struct channelRPCResponseInit {
    int requestID;
    byte subcommand;
    Status status;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel RPC init request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Client generated request ID.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequestIF</td>
      <td>pvRequest Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvRequest</td>
      <td>pvRequest structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel RPC init response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x08, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
  </tbody>
</table>

<p>After RPC request is successfully initialized, client can issue actual RPC
request(s). </p>
<pre>struct channelRPCRequest {
    int serverChannelID;
    int requestID;
    byte subcommand = 0x00 mask for RPC; 0x10 mask for DESTROY;
    FieldDesc pvStructureIF;
    PVField pvStructureData;
};

struct channelRPCResponse {
    int requestID;
    byte subcommand;
    Status status;
    [if status.type == OK | WARNING] FieldDesc pvResponseIF;
    [if status.type == OK | WARNING] PVField pvResponseData;
};</pre>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel RPC request.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">serverChannelID</td>
      <td>Server generated channel ID, same as in create channel response.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in init message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>0x00 for RPC, additional 0x10 mask for DESTROY.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvStructureIF</td>
      <td>pvStructureData Field description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvStructureData</td>
      <td>Argument data structure.</td>
    </tr>
  </tbody>
</table>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Channel RPC response.</caption>
  <tbody>
    <tr>
      <th>Member</th>
      <th>Description</th>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">requestID</td>
      <td>Request ID, same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">subcommand</td>
      <td>Same as in request message.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">status</td>
      <td>Completion status.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvResponseIF</td>
      <td>pvResponseDataField description.</td>
    </tr>
    <tr>
      <td style="text-align:right;font-family:monospace">pvResponseData</td>
      <td>Response data structure.</td>
    </tr>
  </tbody>
</table>

<h2 id="controlMessages">Control Messages</h2>

<p>This section describes all the control messages (0-th bit of
<i>pvAccessHeader.flags</i> is set) for different
<i>pvAccessHeader.messageType</i> values. </p>

<p>Control messages are messages without payload and are used internally by the
procotol, e.g. to handle byte order, flow control. Payload size field contains
control message specific value. </p>

<h3 id="protocolMessages:controlMessages:mark">Mark Total Byte Sent (0x00)</h3>

<p>Payload size field holds the value of total bytes sent. Client should
respond with acknowledgment control message (0x01) as soon as possible. </p>

<h3 id="protocolMessages:controlMessages:ackMark">Acknowledge Total Bytes
Received (0x01)</h3>

<p>Payload size field holds the acknowledge value of total bytes received (must
match previously received marked value). </p>

<h3 id="protocolMessages:controlMessages:endianess">Announce byte-order
(0x02)</h3>

<p>7-th bit of header flags field indicated selected byte-order. Payload equals
0. <br />
This MUST be the first message sent by a server when connection is established.
<br />
NOTE: message is byte-order independed. </p>

<h3 id="protocolMessages:controlMessages:echoRequest">Echo request (0x03)</h3>

<p>Diagnostic/test echo message. Receiver should respond with Echo response
(0x04) message with the same payload size field value. </p>

<h3 id="protocolMessages:controlMessages:echoResponse">Echo response (0x04)</h3>

<p>Response to a echo request. Payload size field contains the same value as in
request message. </p>

<h2 id="communicationExample">Communication Example</h2>

<table style="caption-side:bottom">
  <caption style="font-weight:bold">Communication Example.</caption>
  <tbody>
    <tr>
      <th>Server</th>
      <th></th>
      <th>Client</th>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>searchRequest (UDP broadcast/multicast)</td>
    </tr>
    <tr>
      <td>searchResponse (UDP unicast)</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td align="left" colspan="3">TCP/IP connection established</td>
    </tr>
    <tr>
      <td>announceByteOrderControlMessage</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td>connectionValidationRequest</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>connectionValidationResponse</td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>createChannelRequest</td>
    </tr>
    <tr>
      <td>createChannelResponse</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>channelGetRequestInit</td>
    </tr>
    <tr>
      <td>channelGetResponseInit</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>channelGetRequest</td>
    </tr>
    <tr>
      <td>channelGetResponse</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>. . .</td>
    </tr>
    <tr>
      <td>. . .</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>destroyRequest</td>
    </tr>
    <tr>
      <td></td>
      <td>&lt;----</td>
      <td>channelDestroyRequest</td>
    </tr>
    <tr>
      <td>channelDestroyResponse</td>
      <td>----&gt;</td>
      <td></td>
    </tr>
  </tbody>
</table>

<h2 id="futureProtocolChanges">Future Protocol Changes/Updates</h2>

<p>The following are known items that should be specified in future revisions:
</p>
<ul>
  <li>"one-phase" get/put/get-put/process</li>
  <li>immutable fields support, cache implemented for values (useful for
  enums)</li>
  <li>optimized packed Monitor responses</li>
  <li>bulk message transfer/trottle public API</li>
  <li>access rights</li>
  <li>etc.</li>
</ul>
</body>
</html>
